import lex
import parse

function(EleList eles) parse::lookahead_is_accessor -> bool does
	if eles:get_lookahead().is_token do
		if (eles:get_lookahead():t().type_.name=="T_DOT"):or(\
			eles:get_lookahead():t().type_.name=="T_COLON"):or(\
			eles:get_lookahead():t().type_.name=="T_DOUBLECOLON") do
			return true
		done
	done
return false

type BinOpExpr is packed
	NodeType type_
	cstr op
	Node lhs
	Node rhs

	function(BinOpExpr node, int depth) BinOpExpr::print -> void does
		printf("BinOpExpr (Operator='%s')\n", node.op)
		parse::indent(depth)
		printf("|- LHS: ")
		node.lhs:print(depth+1)

		parse::indent(depth)
		printf("\- RHS: ")
		node.rhs:print(depth+1)
	return

	function(EleList eles) BinOpExpr::create -> BinOpExpr does
		BinOpExpr new = malloc(@sizeof(BinOpExpr)@)|BinOpExpr
		new.lhs=eles:get(0):n()
		new.op=eles:get(1):t().text
		new.rhs=eles:get(2):n()
	return new

	function(EleList eles) BinOpExpr::match -> int does
		if eles:get(0).is_token:or(\
		  -eles:get(1).is_token):or(\
		   eles:get(2).is_token) do
			return 0
		done

		if (eles:get(1):t().type_.name!="T_BINOP"):or(\
		   -eles:get(0):n():is_a("ValueExpression")):or(\
		   -eles:get(0):n():is_a("ValueExpression")) do
			return 0
		done

		if parse::lookahead_is_accessor(eles) do
			return 0
		done
	return 3

	function() BinOpExpr::impl -> NodeType does
	return NodeType::new("BinOpExpr")\
					:set_printer(BinOpExpr::print |NodePrinter)\
					:set_creator(BinOpExpr::create|NodeCreator)\
					:set_matcher(BinOpExpr::match |NodeMatcher)\
					:matches(3):addtype("ValueExpression")
endtype

type AssignmentExpr is packed
	NodeType type_
	cstr op
	Node lhs
	Node rhs

	function(AssignmentExpr node, int depth) AssignmentExpr::print -> void does
		printf("AssignmentExpr (Operator='%s')\n", node.op)
		parse::indent(depth)
		printf("|- LHS: ")
		node.lhs:print(depth+1)

		parse::indent(depth)
		printf("\- RHS: ")
		node.rhs:print(depth+1)
	return

	function(EleList eles) AssignmentExpr::create -> AssignmentExpr does
		AssignmentExpr new = malloc(@sizeof(AssignmentExpr)@)|AssignmentExpr
		new.lhs=eles:get(0):n()
		new.op=eles:get(1):t().text
		new.rhs=eles:get(2):n()
	return new

	function(EleList eles) AssignmentExpr::match -> int does
		if eles:get(0).is_token:or(\
		  -eles:get(1).is_token):or(\
		   eles:get(2).is_token) do
			return 0
		done

		if (-(\
				(eles:get(1):t().type_.name=="T_ASSIGN"):or(\
		 		eles:get(1):t().type_.name=="T_AUGASSIGN"))):or(\
		   -eles:get(0):n():is_a("IdentifierExpression")):or(\
		   -eles:get(2):n():is_a("ValueExpression")) do
			return 0
		done

		if parse::lookahead_is_accessor(eles) do
			return 0
		done
	return 3

	function() AssignmentExpr::impl -> NodeType does
	return NodeType::new("AssignmentExpr")\
					:set_printer(AssignmentExpr::print |NodePrinter)\
					:set_creator(AssignmentExpr::create|NodeCreator)\
					:set_matcher(AssignmentExpr::match |NodeMatcher)\
					:matches(3):addtype("Expression")
endtype

type AccessorExpr is packed
	NodeType type_
	cstr mode
	Node object
	Node field

	function(AccessorExpr node, int depth) AccessorExpr::print -> void does
		printf("AccessorExpr (Mode='%s')\n", node.mode)
		parse::indent(depth)
		printf("|- Object: ")
		node.object:print(depth+1)

		parse::indent(depth)
		printf("\- Field: ")
		node.field:print(depth+1)
	return

	function(EleList eles) AccessorExpr::create -> AccessorExpr does
		AccessorExpr new = malloc(@sizeof(AccessorExpr)@)|AccessorExpr
		new.object=eles:get(0):n()
		new.mode=eles:get(1):t().text
		new.field=eles:get(2):n()
	return new

	function(EleList eles) AccessorExpr::match -> int does
		if eles:get(0).is_token:or(\
		  -eles:get(1).is_token):or(\
		   eles:get(2).is_token) do
			return 0
		done

		if (-(\
				(eles:get(1):t().type_.name=="T_DOT"):or(\
		 		eles:get(1):t().type_.name=="T_COLON"):or(\
		 		eles:get(1):t().type_.name=="T_DOUBLECOLON"))):or(\
		   -eles:get(0):n():is_a("ValueExpression")):or(\
		   -eles:get(2):n():is_a("NameExpr")) do
			return 0
		done

		if parse::lookahead_is_accessor(eles) do
			return 0
		done
	return 3

	function() AccessorExpr::impl -> NodeType does
	return NodeType::new("AccessorExpr")\
					:set_printer(AccessorExpr::print |NodePrinter)\
					:set_creator(AccessorExpr::create|NodeCreator)\
					:set_matcher(AccessorExpr::match |NodeMatcher)\
					:matches(3):addtype("IdentifierExpression")
endtype

type NameExpr is packed
	NodeType type_
	cstr name

	function(NameExpr node, int depth) NameExpr::print -> void does
		printf("NameExpr: '%s'\n", node.name)
	return

	function(EleList eles) NameExpr::create -> NameExpr does
		NameExpr new = malloc(@sizeof(NameExpr)@)|NameExpr
		new.name=eles:get(0):t().text
	return new

	function(EleList eles) NameExpr::match -> int does
	return (eles:get(0):t().type_.name=="T_NAME")|int

	function() NameExpr::impl -> NodeType does
	return NodeType::new("NameExpr")\
					:set_printer(NameExpr::print |NodePrinter)\
					:set_creator(NameExpr::create|NodeCreator)\
					:set_matcher(NameExpr::match |NodeMatcher)\
					:matches(1):matches_only_tokens():addtype("IdentifierExpression")
endtype

type LiteralExpr is packed
	NodeType type_
	cstr value
	cstr value_type

	function(LiteralExpr node, int depth) LiteralExpr::print -> void does
		printf("LiteralExpr: type=%s, value=%s\n", node.value_type, node.value)
	return

	function(EleList eles) LiteralExpr::create -> LiteralExpr does
		LiteralExpr new = malloc(@sizeof(LiteralExpr)@)|LiteralExpr
		new.value=eles:get(0):t().text
		if eles:get(0):t().type_.name=="T_INT_LITERAL" do
			new.value_type="int"
		elif eles:get(0):t().type_.name=="T_FLOAT_LITERAL" do
			new.value_type="float"
		else do
			new.value_type="cstr"
		done
	return new

	function(EleList eles) LiteralExpr::match -> int does
	return ((eles:get(0):t().type_.name=="T_INT_LITERAL")+\
		    (eles:get(0):t().type_.name=="T_FLOAT_LITERAL")+\
		    (eles:get(0):t().type_.name=="T_STRING_LITERAL"))|int

	function() LiteralExpr::impl -> NodeType does
	return NodeType::new("LiteralExpr")\
					:set_printer(LiteralExpr::print |NodePrinter)\
					:set_creator(LiteralExpr::create|NodeCreator)\
					:set_matcher(LiteralExpr::match |NodeMatcher)\
					:matches(1):matches_only_tokens():addtype("ValueExpression")
endtype

type DeclExpr is packed
	NodeType type_
	cstr name

	function(DeclExpr node, int depth) DeclExpr::print -> void does
		printf("DeclExpr: '%s'\n", node.name)
	return

	function(EleList eles) DeclExpr::create -> DeclExpr does
		DeclExpr new = malloc(@sizeof(DeclExpr)@)|DeclExpr
		new.name=eles:get(0):t().text
	return new

	function(EleList eles) DeclExpr::match -> int does
	return (eles:get(0):t().type_.name=="T_VAR_DECL")|int

	function() DeclExpr::impl -> NodeType does
	return NodeType::new("DeclExpr")\
					:set_printer(DeclExpr::print |NodePrinter)\
					:set_creator(DeclExpr::create|NodeCreator)\
					:set_matcher(DeclExpr::match |NodeMatcher)\
					:matches(1):matches_only_tokens():addtype("IdentifierExpression")
endtype

type GroupingExpr is packed
	NodeType type_
	Node contents

	function(GroupingExpr node, int depth) GroupingExpr::print -> void does
		printf("GroupingExpr: ")
		node.contents:print(depth+1)
	return

	function(EleList eles) GroupingExpr::create -> GroupingExpr does
		GroupingExpr new = malloc(@sizeof(GroupingExpr)@)|GroupingExpr
		new.contents=eles:get(1):n()
	return new

	function(EleList eles) GroupingExpr::match -> int does
		if (-eles:get(0).is_token):or(\
		     eles:get(1).is_token):or(\
		    -eles:get(2).is_token) do
			return 0
		done

		if (eles:get(0):t().type_.name!="T_PAREN_OPEN"):or(\
			eles:get(2):t().type_.name!="T_PAREN_CLOSE"):or(\
		   -eles:get(1):n():is_a("ValueExpression")) do
			return 0
		done
	return 3

	function() GroupingExpr::impl -> NodeType does
	return NodeType::new("GroupingExpr")\
					:set_printer(GroupingExpr::print |NodePrinter)\
					:set_creator(GroupingExpr::create|NodeCreator)\
					:set_matcher(GroupingExpr::match |NodeMatcher)\
					:matches(3):addtype("ValueExpression"):addtype("Tuple")
endtype

type TupleEndFragment is packed
	NodeType type_
	Node element

	function(TupleEndFragment node, int depth) TupleEndFragment::print -> void does
		printf("TupleEndFragment, element=")
		node.element:print(depth+1)
	return

	function(EleList eles) TupleEndFragment::create -> TupleEndFragment does
		TupleEndFragment new = malloc(@sizeof(TupleEndFragment)@)|TupleEndFragment
		new.element=eles:get(1):n()
	return new

	function(EleList eles) TupleEndFragment::match -> int does
		if (-eles:get(0).is_token):or(\
		     eles:get(1).is_token):or(\
		    -eles:get(2).is_token) do
			return 0
		done

		if (eles:get(0):t().type_.name!="T_COMMA"):or(\
			eles:get(2):t().type_.name!="T_PAREN_CLOSE"):or(\
		   -eles:get(1):n():is_a("ValueExpression")) do
			return 0
		done
	return 3

	function() TupleEndFragment::impl -> NodeType does
	return NodeType::new("TupleEndFragment")\
					:set_printer(TupleEndFragment::print |NodePrinter)\
					:set_creator(TupleEndFragment::create|NodeCreator)\
					:set_matcher(TupleEndFragment::match |NodeMatcher)\
					:matches(3):addtype("TupleFragment")
endtype

type TupleMidFragment is packed
	NodeType type_
	List elements

	function(TupleMidFragment node, int depth) TupleMidFragment::print -> void does
		printf("TupleMidFragment: (Length=%i)\n", node.elements.len)
		int i=0
		while i<node.elements.len do
			parse::indent(depth)
			printf("|%i- ", i)
			node.elements:get_Node(i):print(depth+1)
			i+=1
		done
	return

	function(EleList eles) TupleMidFragment::create -> TupleMidFragment does
		TupleMidFragment new = malloc(@sizeof(TupleMidFragment)@)|TupleMidFragment
		if eles:get(2):n():is_a("TupleEndFragment") do
			new.elements=List::new()
			new.elements:append_Node(eles:get(1):n())
			new.elements:append_Node((eles:get(2):n()|TupleEndFragment).element)
		else do
			new.elements=List::copy((eles:get(2):n()|TupleMidFragment).elements)
			new.elements:insert(0, eles:get(1):n()|ptr)
		done
	return new

	function(EleList eles) TupleMidFragment::match -> int does
		if (-eles:get(0).is_token):or(\
		     eles:get(1).is_token):or(\
		     eles:get(2).is_token) do
			return 0
		done

		if (eles:get(0):t().type_.name!="T_COMMA"):or(\
		   -eles:get(1):n():is_a("ValueExpression")):or(\
		   -eles:get(2):n():is_a("TupleFragment")) do
			return 0
		done
	return 3

	function() TupleMidFragment::impl -> NodeType does
	return NodeType::new("TupleMidFragment")\
					:set_printer(TupleMidFragment::print |NodePrinter)\
					:set_creator(TupleMidFragment::create|NodeCreator)\
					:set_matcher(TupleMidFragment::match |NodeMatcher)\
					:matches(3):addtype("TupleFragment")
endtype

type Tuple is packed
	NodeType type_
	List elements

	function(Tuple node, int depth) Tuple::print -> void does
		printf("Tuple: (Length=%i)\n", node.elements.len)
		int i=0
		while i<node.elements.len do
			parse::indent(depth)
			if i==node.elements.len-1 do
				printf("\\%i- ", i)
			else do
				printf("|%i- ", i)
			done
			node.elements:get_Node(i):print(depth+1)
			i+=1
		done
	return

	function(EleList eles) Tuple::create -> Tuple does
		Tuple new = malloc(@sizeof(Tuple)@)|Tuple
		if eles:get(2):n():is_a("TupleEndFragment") do
			new.elements=List::new()
			new.elements:append_Node(eles:get(1):n())
			new.elements:append_Node((eles:get(2):n()|TupleEndFragment).element)
		else do
			new.elements=List::copy((eles:get(2):n()|TupleMidFragment).elements)
			new.elements:insert(0, eles:get(1):n()|ptr)
		done
	return new

	function(EleList eles) Tuple::match -> int does
		if (-eles:get(0).is_token):or(\
		     eles:get(1).is_token):or(\
		     eles:get(2).is_token) do
			return 0
		done

		if (eles:get(0):t().type_.name!="T_PAREN_OPEN"):or(\
		   -eles:get(2):n():is_a("TupleFragment")):or(\
		   -eles:get(1):n():is_a("ValueExpression")) do
			return 0
		done
	return 3

	function() Tuple::impl -> NodeType does
	return NodeType::new("Tuple")\
					:set_printer(Tuple::print |NodePrinter)\
					:set_creator(Tuple::create|NodeCreator)\
					:set_matcher(Tuple::match |NodeMatcher)\
					:matches(3)
endtype

type ZeroTuple is packed
	NodeType type_

	function(ZeroTuple node, int depth) ZeroTuple::print -> void does
		printf("ZeroTuple: (Length=0)\n")
	return

	function(EleList eles) ZeroTuple::create -> ZeroTuple does
		ZeroTuple new = malloc(@sizeof(ZeroTuple)@)|ZeroTuple
	return new

	function(EleList eles) ZeroTuple::match -> int does
		if (eles:get(0):t().type_.name!="T_PAREN_OPEN"):or(\
		    eles:get(1):t().type_.name!="T_PAREN_CLOSE") do
			return 0
		done
	return 2

	function() ZeroTuple::impl -> NodeType does
	return NodeType::new("ZeroTuple")\
					:set_printer(ZeroTuple::print |NodePrinter)\
					:set_creator(ZeroTuple::create|NodeCreator)\
					:set_matcher(ZeroTuple::match |NodeMatcher)\
					:matches(2):matches_only_tokens():addtype("Tuple")
endtype

type CallExpr is packed
	NodeType type_
	Node meth
	List args

	function(CallExpr node, int depth) CallExpr::print -> void does
		printf("CallExpr:\n")
		parse::indent(depth)
		printf("|- Method: ")
		node.meth:print(depth+1)

		parse::indent(depth)
		printf("\- Arguments: (Len=%i)\n", node.args.len)
		int i=0
		while i<node.args.len do
			parse::indent(depth+1)
			if i==node.args.len-1 do
				printf("\\%i- ", i)
			else do
				printf("|%i- ", i)
			done
			node.args:get_Node(i):print(depth+2)
			i+=1
		done
	return

	function(EleList eles) CallExpr::create -> CallExpr does
		CallExpr new = malloc(@sizeof(CallExpr)@)|CallExpr
		new.meth=eles:get(0):n()
		Node args = eles:get(1):n()
		if args:is_a("ZeroTuple") do
			new.args=List::new()
		elif args:is_a("GroupingExpr") do
			new.args=List::new()
			new.args:append_Node((args|GroupingExpr).contents)
		else do
			new.args=List::copy((args|Tuple).elements)
		done
	return new

	function(EleList eles) CallExpr::match -> int does
		if (-eles:get(0):n():is_a("IdentifierExpression")):or(\
		    -eles:get(1):n():is_a("Tuple")) do
			return 0
		done

		if parse::lookahead_is_accessor(eles) do
			return 0
		done
	return 2

	function() CallExpr::impl -> NodeType does
	return NodeType::new("CallExpr")\
					:set_printer(CallExpr::print |NodePrinter)\
					:set_creator(CallExpr::create|NodeCreator)\
					:set_matcher(CallExpr::match |NodeMatcher)\
					:matches(2):matches_only_nodes():addtype("ValueExpression")
endtype

type ZeroArgList is packed
	NodeType type_

	function(ZeroArgList node, int depth) ZeroArgList::print -> void does
		printf("ZeroArgList: (Size=0)\n")
	return

	function(EleList eles) ZeroArgList::create -> ZeroArgList does
		ZeroArgList new = malloc(@sizeof(ZeroArgList)@)|ZeroArgList
	return new

	function(EleList eles) ZeroArgList::match -> int does
		if (-eles:get(0):t():is_a("T_ARGLIST_START")):or(\
		    -eles:get(1):t():is_a("T_ARGLIST_END")) do
			return 0
		done
	return 2

	function() ZeroArgList::impl -> NodeType does
	return NodeType::new("ZeroArgList")\
					:set_printer(ZeroArgList::print |NodePrinter)\
					:set_creator(ZeroArgList::create|NodeCreator)\
					:set_matcher(ZeroArgList::match |NodeMatcher)\
					:matches(2):matches_only_tokens():addtype("ArgList")
endtype

type OneArgList is packed
	NodeType type_
	cstr text

	function(OneArgList node, int depth) OneArgList::print -> void does
		printf("OneArgList: (Size=1)\n")
		parse::indent(depth+1)
		printf("\\0- %s\n", node.text)
	return

	function(EleList eles) OneArgList::create -> OneArgList does
		OneArgList new = malloc(@sizeof(OneArgList)@)|OneArgList
		new.text=eles:get(1):t().text
	return new

	function(EleList eles) OneArgList::match -> int does
		if (-eles:get(0):t():is_a("T_ARGLIST_START")):or(\
		    -eles:get(1):t():is_a("T_ARGLIST_ELE")):or(\
		    -eles:get(2):t():is_a("T_ARGLIST_END")) do
			return 0
		done
	return 3

	function() OneArgList::impl -> NodeType does
	return NodeType::new("OneArgList")\
					:set_printer(OneArgList::print |NodePrinter)\
					:set_creator(OneArgList::create|NodeCreator)\
					:set_matcher(OneArgList::match |NodeMatcher)\
					:matches(3):matches_only_tokens():addtype("ArgList")
endtype

type MultiArgListStart is packed
	NodeType type_
	cstr text

	function(MultiArgListStart node, int depth) MultiArgListStart::print -> void does
		printf("MultiArgListStart: (Size=1)\n")
		parse::indent(depth+1)
		printf("\\0- %s\n", node.text)
	return

	function(EleList eles) MultiArgListStart::create -> MultiArgListStart does
		MultiArgListStart new = malloc(@sizeof(MultiArgListStart)@)|MultiArgListStart
		new.text=eles:get(1):t().text
	return new

	function(EleList eles) MultiArgListStart::match -> int does
		if (-eles:get(0):t():is_a("T_ARGLIST_SEP")):or(\
		    -eles:get(1):t():is_a("T_ARGLIST_ELE")):or(\
		    -eles:get(2):t():is_a("T_ARGLIST_END")) do
			return 0
		done
	return 3

	function() MultiArgListStart::impl -> NodeType does
	return NodeType::new("MultiArgListStart")\
					:set_printer(MultiArgListStart::print |NodePrinter)\
					:set_creator(MultiArgListStart::create|NodeCreator)\
					:set_matcher(MultiArgListStart::match |NodeMatcher)\
					:matches(3):matches_only_tokens():addtype("MultiArgListFragment")
endtype

type MultiArgListExt is packed
	NodeType type_
	List args

	function(MultiArgListExt node, int depth) MultiArgListExt::print -> void does
		printf("MultiArgListExt: (Size=%i)\n", node.args.len)
		int i=0
		while i<node.args.len do
			parse::indent(depth+1)
			if i==node.args.len-1 do
				printf("\\%i- %s\n", i, node.args:get(i))
			else do
				printf("|%i- %s\n", i, node.args:get(i))
			done
			i+=1
		done
	return

	function(EleList eles) MultiArgListExt::create -> MultiArgListExt does
		MultiArgListExt new = malloc(@sizeof(MultiArgListExt)@)|MultiArgListExt
		Node ele = eles:get(2):n()
		if ele:is_a("MultiArgListStart") do
			new.args=List::new()
			new.args:append(eles:get(1):t().text)
			new.args:append((eles:get(2):n()|MultiArgListStart).text)
		else do #it's a MultiArgListExt
			new.args=(ele|MultiArgListExt).args
			new.args:insert(0, eles:get(1):t().text)
		done
	return new

	function(EleList eles) MultiArgListExt::match -> int does
		if (-eles:get(0).is_token):or(\
			-eles:get(1).is_token):or(\
			 eles:get(2).is_token) do
			return 0
		done

		if (-eles:get(0):t():is_a("T_ARGLIST_SEP")):or(\
		    -eles:get(1):t():is_a("T_ARGLIST_ELE")):or(\
		    -eles:get(2):n():is_a("MultiArgListFragment")) do
			return 0
		done
	return 3

	function() MultiArgListExt::impl -> NodeType does
	return NodeType::new("MultiArgListExt")\
					:set_printer(MultiArgListExt::print |NodePrinter)\
					:set_creator(MultiArgListExt::create|NodeCreator)\
					:set_matcher(MultiArgListExt::match |NodeMatcher)\
					:matches(3):addtype("MultiArgListFragment")
endtype

type MultiArgList is packed
	NodeType type_
	List args

	function(MultiArgList node, int depth) MultiArgList::print -> void does
		printf("MultiArgList: (Size=%i)\n", node.args.len)
		int i=0
		while i<node.args.len do
			parse::indent(depth+1)
			if i==node.args.len-1 do
				printf("\\%i- %s\n", i, node.args:get(i))
			else do
				printf("|%i- %s\n", i, node.args:get(i))
			done
			i+=1
		done
	return

	function(EleList eles) MultiArgList::create -> MultiArgList does
		MultiArgList new = malloc(@sizeof(MultiArgList)@)|MultiArgList
		Node ele = eles:get(2):n()
		if ele:is_a("MultiArgListStart") do
			new.args=List::new()
			new.args:append(eles:get(1):t().text)
			new.args:append((eles:get(2):n()|MultiArgListStart).text)
		else do #it's a MultiArgList
			new.args=(ele|MultiArgList).args
			new.args:insert(0, eles:get(1):t().text)
		done
	return new

	function(EleList eles) MultiArgList::match -> int does
		if (-eles:get(0).is_token):or(\
			-eles:get(1).is_token):or(\
			 eles:get(2).is_token) do
			return 0
		done

		if (-eles:get(0):t():is_a("T_ARGLIST_START")):or(\
		    -eles:get(1):t():is_a("T_ARGLIST_ELE")):or(\
		    -eles:get(2):n():is_a("MultiArgListFragment")) do
			return 0
		done
	return 3

	function() MultiArgList::impl -> NodeType does
	return NodeType::new("MultiArgList")\
					:set_printer(MultiArgList::print |NodePrinter)\
					:set_creator(MultiArgList::create|NodeCreator)\
					:set_matcher(MultiArgList::match |NodeMatcher)\
					:matches(3):addtype("ArgList")
endtype

type FunctionDecl is packed
	NodeType type_
	List args
	cstr name
	cstr ret_type

	function(FunctionDecl node, int depth) FunctionDecl::print -> void does
		printf("FunctionDecl: Name='%s' Type='%s' Nargs=%i\n", node.name, node.ret_type, node.args.len)
		int i=0
		while i<node.args.len do
			parse::indent(depth+1)
			if i==node.args.len-1 do
				printf("\\%i- %s\n", i, node.args:get(i))
			else do
				printf("|%i- %s\n", i, node.args:get(i))
			done
			i+=1
		done
	return

	function(EleList eles) FunctionDecl::create -> FunctionDecl does
		FunctionDecl new = malloc(@sizeof(FunctionDecl)@)|FunctionDecl
		new.name=eles:get(2):t().text
		new.ret_type=eles:get(4):t().text

		Node args = eles:get(1):n()
		if args:is_a("ZeroArgList") do
			new.args=List::new()
		elif args:is_a("OneArgList") do
			new.args=List::new()
			new.args:append((eles:get(1):n()|OneArgList).text)
		else do #it's a MultiArgList
			new.args=(eles:get(1):n()|MultiArgList).args
		done
	return new

	function(EleList eles) FunctionDecl::match -> int does
		#T_FUNCTIONDECL ArgList T_FUNCTIONDECL_NAME T_FUNCTIONDECL_RETURN T_FUNCTIONDECL_RETURN_TY
		#...T_FUNCTIONDECL_DOES
		if (-eles:get(0).is_token):or(\
			 eles:get(1).is_token):or(\
			-eles:get(2).is_token):or(\
			-eles:get(3).is_token):or(\
			-eles:get(4).is_token):or(\
			-eles:get(5).is_token) do
			return 0
		done

		if (-eles:get(0):t():is_a("T_FUNCTIONDECL")):or(\
		    -eles:get(1):n():is_a("ArgList")):or(\
		    -eles:get(2):t():is_a("T_FUNCTIONDECL_NAME")):or(\
		    -eles:get(3):t():is_a("T_FUNCTIONDECL_RETURN")):or(\
		    -eles:get(4):t():is_a("T_FUNCTIONDECL_RETURN_TY")):or(\
		    -eles:get(5):t():is_a("T_FUNCTIONDECL_DOES")) do
			return 0
		done
	return 6

	function() FunctionDecl::impl -> NodeType does
	return NodeType::new("FunctionDecl")\
					:set_printer(FunctionDecl::print |NodePrinter)\
					:set_creator(FunctionDecl::create|NodeCreator)\
					:set_matcher(FunctionDecl::match |NodeMatcher)\
					:matches(6)
endtype


function() parse::init -> void does
	List l=List::new()

	l:append_NodeType(BinOpExpr::impl())
	l:append_NodeType(NameExpr::impl())
	l:append_NodeType(LiteralExpr::impl())
	l:append_NodeType(DeclExpr::impl())
	l:append_NodeType(GroupingExpr::impl())
	l:append_NodeType(AssignmentExpr::impl())
	l:append_NodeType(AccessorExpr::impl())

	l:append_NodeType(TupleEndFragment::impl())
	l:append_NodeType(TupleMidFragment::impl())
	l:append_NodeType(Tuple::impl())
	l:append_NodeType(ZeroTuple::impl())
	l:append_NodeType(CallExpr::impl())

	l:append_NodeType(ZeroArgList::impl())
	l:append_NodeType(OneArgList::impl())
	l:append_NodeType(MultiArgListStart::impl())
	l:append_NodeType(MultiArgListExt::impl())
	l:append_NodeType(MultiArgList::impl())
	l:append_NodeType(FunctionDecl::impl())

	parse_node_types=l
return

function() parse::show_types -> void does
	int p=0
	int i
	NodeType t
	while p<parse_node_types.len do
		t=parse_node_types:get(p)|NodeType
		printf("\n%s: %s ", t.name, t.name)
		if t.things_i_am|ptr!=null do
			i=0
			while i<t.things_i_am.len do
				printf("%s ", t.things_i_am:get(i)|cstr)
				i+=1
			done
		done
		printf("\t->is_a('TupleFragment')=%i", t:is_a("TupleFragment")|int)
		p+=1
	done
	printf("\n")
return