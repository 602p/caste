import lex
import parse

function(EleList eles) parse::lookahead_is_accessor -> bool does
	if eles:has_lookahead() do
		if eles:get_lookahead().is_token do
			if (eles:get_lookahead():t().type_.name=="T_DOT"):or(\
				eles:get_lookahead():t().type_.name=="T_COLON"):or(\
				eles:get_lookahead():t().type_.name=="T_DOUBLECOLON"):or(\
				eles:get_lookahead():t().type_.name=="T_CAST") do #Pretty much an accessor, transforms type
				return true
			done
		done
	done
return false

function(EleList eles) parse::lookahead_is_possibly_function -> bool does
	if eles:has_lookahead() do
		if eles:get_lookahead().is_token do
			if eles:get_lookahead():t():is_a("T_NAME"):or(\
			   eles:get_lookahead():t():is_a("T_PAREN_CLOSE")):or(\
			   eles:get_lookahead():t():is_a("T_BRACKET_CLOSE")) do
			   return true #Cases where it may be a function invocation
			done
		done
	done
return false

import "grammar/access.ort"
import "grammar/assignment.ort"
import "grammar/binop.ort"
import "grammar/blockbody.ort"
import "grammar/call.ort"
import "grammar/cast.ort"
import "grammar/fdecl.ort"
import "grammar/fdecl_arglist.ort"
import "grammar/grouping.ort"
import "grammar/if.ort"
import "grammar/import.ort"
import "grammar/index.ort"
import "grammar/intrinsic.ort"
import "grammar/literal.ort"
import "grammar/name.ort"
import "grammar/return.ort"
import "grammar/sep.ort"
import "grammar/tuple.ort"
import "grammar/typedecl.ort"
import "grammar/unop.ort"
import "grammar/while.ort"
import "grammar/file.ort"

function(List l) parse::init_default -> void does
	l:append_NodeType(NameExpr::impl())
	l:append_NodeType(DeclExpr::impl())
	l:append_NodeType(AccessorExpr::impl())

	l:append_NodeType(LiteralExpr::impl())
	
	l:append_NodeType(GroupingExpr::impl())
	l:append_NodeType(BinOpExpr::impl())
	l:append_NodeType(UnOpExpr::impl())
	l:append_NodeType(CastExpr::impl())
	l:append_NodeType(IndexExpr::impl())

	l:append_NodeType(CallExpr::impl())

	l:append_NodeType(AssignmentExpr::impl())
	l:append_NodeType(ReturnExpr::impl())

	l:append_NodeType(TupleEndFragment::impl())
	l:append_NodeType(TupleMidFragment::impl())
	l:append_NodeType(Tuple::impl())
	l:append_NodeType(ZeroTuple::impl())

	l:append_NodeType(ZeroArgList::impl())
	l:append_NodeType(OneArgList::impl())
	l:append_NodeType(MultiArgListStart::impl())
	l:append_NodeType(MultiArgListExt::impl())
	l:append_NodeType(MultiArgList::impl())
	l:append_NodeType(FunctionDeclHead::impl())

	l:append_NodeType(FunctionBody::impl())
	l:append_NodeType(FunctionDecl::impl())

	l:append_NodeType(IfExprHead::impl())
	l:append_NodeType(IfExpr::impl())
	l:append_NodeType(WhileExpr::impl())
	l:append_NodeType(BlockBody::impl())

	l:append_NodeType(IntrinsicExpr::impl())
	l:append_NodeType(ImportStmt::impl())

	l:append_NodeType(TypeDeclHead::impl())
	l:append_NodeType(TypeDeclBody::impl())
	l:append_NodeType(TypeDecl::impl())

	l:append_NodeType(SepExpr::impl())

	l:append_NodeType(OneTuple::impl()) #Fallback matching case for one-arg function calls

	l:append_NodeType(FileNode::impl())
return

function(Project proj) Project:show_types -> void does
	int p=0
	int i
	NodeType t
	while p<proj.node_types.len do
		t=proj.node_types:get(p)|NodeType
		printf("\n%s%s:", t.name, " "*(20-t.name:len()))
		if t.things_i_am|ptr!=null do
			i=t.things_i_am.len-1
			while i>-1 do
				printf(" %s%s", t.things_i_am:get(i)|cstr, " "*(25-(t.things_i_am:get(i)|cstr):len()))
				i-=1
			done
		done
		printf(" %s", t.name)
		p+=1
	done
	printf("\n")
return