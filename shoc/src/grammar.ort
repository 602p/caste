import lex
import parse

function(EleList eles) parse::lookahead_is_accessor -> bool does
	if eles:has_lookahead() do
		if eles:get_lookahead().is_token do
			if (eles:get_lookahead():t().type_.name=="T_DOT"):or(\
				eles:get_lookahead():t().type_.name=="T_COLON"):or(\
				eles:get_lookahead():t().type_.name=="T_DOUBLECOLON"):or(\
				eles:get_lookahead():t().type_.name=="T_CAST") do #Pretty much an accessor, transforms type
				return true
			done
		done
	done
return false

function(EleList eles) parse::lookahead_is_possibly_function -> bool does
	if eles:has_lookahead() do
		if eles:get_lookahead().is_token do
			if eles:get_lookahead():t():is_a("T_NAME"):or(\
			   eles:get_lookahead():t():is_a("T_PAREN_CLOSE")):or(\
			   eles:get_lookahead():t():is_a("T_BRACKET_CLOSE")) do
			   return true #Cases where it may be a function invocation
			done
		done
	done
return false

type BinOpExpr is packed
	NodeType type_
	cstr op
	Node lhs
	Node rhs

	function(BinOpExpr node, int depth) BinOpExpr::print -> void does
		printf("BinOpExpr (Operator='%s')\n", node.op)
		parse::indent(depth)
		printf("|- LHS: ")
		node.lhs:print(depth+1)

		parse::indent(depth)
		printf("\- RHS: ")
		node.rhs:print(depth+1)
	return

	function(EleList eles) BinOpExpr::create -> BinOpExpr does
		BinOpExpr new = malloc(@sizeof(BinOpExpr)@)|BinOpExpr
		new.lhs=eles:get(0):n()
		new.op=eles:get(1):t().text
		new.rhs=eles:get(2):n()
	return new

	function(EleList eles) BinOpExpr::match -> int does
		if eles:get(0).is_token:or(\
		  -eles:get(1).is_token):or(\
		   eles:get(2).is_token) do
			return 0
		done

		if (eles:get(1):t().type_.name!="T_BINOP"):or(\
		   -eles:get(0):n():is_a("ValueExpression")):or(\
		   -eles:get(2):n():is_a("ValueExpression")) do
			return 0
		done

		if parse::lookahead_is_accessor(eles) do
			return 0
		done

		if parse::lookahead_is_possibly_function(eles) do
			return 0 #Don't turn a(1)+2 into a,(1)+2
		done
	return 3

	function() BinOpExpr::impl -> NodeType does
	return NodeType::new("BinOpExpr")\
					:set_printer(BinOpExpr::print |NodePrinter)\
					:set_creator(BinOpExpr::create|NodeCreator)\
					:set_matcher(BinOpExpr::match |NodeMatcher)\
					:matches(3):addtype("ValueExpression")
endtype

type UnOpExpr is packed
	NodeType type_
	cstr op
	Node value

	function(UnOpExpr node, int depth) UnOpExpr::print -> void does
		printf("UnOpExpr (Operator='%s')\n", node.op)
		parse::indent(depth)
		printf("\- Value: ")
		node.value:print(depth+1)
	return

	function(EleList eles) UnOpExpr::create -> UnOpExpr does
		UnOpExpr new = malloc(@sizeof(UnOpExpr)@)|UnOpExpr
		new.value=eles:get(1):n()
		new.op=eles:get(0):t().text
	return new

	function(EleList eles) UnOpExpr::match -> int does
		if eles:get(1).is_token:or(\
		  -eles:get(0).is_token) do
			return 0
		done

		if (-eles:get(0):t():is_a("T_UNOP")):or(\
		    -eles:get(1):n():is_a("ValueExpression")) do
			return 0
		done
	return 2

	function() UnOpExpr::impl -> NodeType does
	return NodeType::new("UnOpExpr")\
					:set_printer(UnOpExpr::print |NodePrinter)\
					:set_creator(UnOpExpr::create|NodeCreator)\
					:set_matcher(UnOpExpr::match |NodeMatcher)\
					:matches(2):addtype("ValueExpression")
endtype

type AssignmentExpr is packed
	NodeType type_
	cstr op
	Node lhs
	Node rhs

	function(AssignmentExpr node, int depth) AssignmentExpr::print -> void does
		printf("AssignmentExpr (Operator='%s')\n", node.op)
		parse::indent(depth)
		printf("|- LHS: ")
		node.lhs:print(depth+1)

		parse::indent(depth)
		printf("\- RHS: ")
		node.rhs:print(depth+1)
	return

	function(EleList eles) AssignmentExpr::create -> AssignmentExpr does
		AssignmentExpr new = malloc(@sizeof(AssignmentExpr)@)|AssignmentExpr
		new.lhs=eles:get(0):n()
		new.op=eles:get(1):t().text
		new.rhs=eles:get(2):n()
	return new

	function(EleList eles) AssignmentExpr::match -> int does
		if eles:get(0).is_token:or(\
		  -eles:get(1).is_token):or(\
		   eles:get(2).is_token) do
			return 0
		done

		if (-(\
				(eles:get(1):t().type_.name=="T_ASSIGN"):or(\
		 		eles:get(1):t().type_.name=="T_AUGASSIGN"))):or(\
		   -eles:get(0):n():is_a("IdentifierExpression")):or(\
		   -eles:get(2):n():is_a("ValueExpression")) do
			return 0
		done

		if parse::lookahead_is_accessor(eles) do
			return 0
		done
	return 3

	function() AssignmentExpr::impl -> NodeType does
	return NodeType::new("AssignmentExpr")\
					:set_printer(AssignmentExpr::print |NodePrinter)\
					:set_creator(AssignmentExpr::create|NodeCreator)\
					:set_matcher(AssignmentExpr::match |NodeMatcher)\
					:matches(3):addtype("Expression")
endtype

type AccessorExpr is packed
	NodeType type_
	cstr mode
	Node object
	Node field

	function(AccessorExpr node, int depth) AccessorExpr::print -> void does
		printf("AccessorExpr (Mode='%s')\n", node.mode)
		parse::indent(depth)
		printf("|- Object: ")
		node.object:print(depth+1)

		parse::indent(depth)
		printf("\- Field: ")
		node.field:print(depth+1)
	return

	function(EleList eles) AccessorExpr::create -> AccessorExpr does
		AccessorExpr new = malloc(@sizeof(AccessorExpr)@)|AccessorExpr
		new.object=eles:get(0):n()
		new.mode=eles:get(1):t().text
		new.field=eles:get(2):n()
	return new

	function(EleList eles) AccessorExpr::match -> int does
		if eles:get(0).is_token:or(\
		  -eles:get(1).is_token):or(\
		   eles:get(2).is_token) do
			return 0
		done

		if (-(\
				(eles:get(1):t().type_.name=="T_DOT"):or(\
		 		eles:get(1):t().type_.name=="T_COLON"):or(\
		 		eles:get(1):t().type_.name=="T_DOUBLECOLON"))):or(\
		   -eles:get(0):n():is_a("ValueExpression")):or(\
		   -eles:get(2):n():is_a("NameExpr")) do
			return 0
		done

		if parse::lookahead_is_accessor(eles) do
			return 0
		done
	return 3

	function() AccessorExpr::impl -> NodeType does
	return NodeType::new("AccessorExpr")\
					:set_printer(AccessorExpr::print |NodePrinter)\
					:set_creator(AccessorExpr::create|NodeCreator)\
					:set_matcher(AccessorExpr::match |NodeMatcher)\
					:matches(3):addtype("IdentifierExpression")
endtype

type NameExpr is packed
	NodeType type_
	cstr name

	function(NameExpr node, int depth) NameExpr::print -> void does
		printf("NameExpr: '%s'\n", node.name)
	return

	function(EleList eles) NameExpr::create -> NameExpr does
		NameExpr new = malloc(@sizeof(NameExpr)@)|NameExpr
		new.name=eles:get(0):t().text
	return new

	function(EleList eles) NameExpr::match -> int does
	return (eles:get(0):t().type_.name=="T_NAME")|int

	function() NameExpr::impl -> NodeType does
	return NodeType::new("NameExpr")\
					:set_printer(NameExpr::print |NodePrinter)\
					:set_creator(NameExpr::create|NodeCreator)\
					:set_matcher(NameExpr::match |NodeMatcher)\
					:matches(1):matches_only_tokens():addtype("IdentifierExpression")
endtype

type LiteralExpr is packed
	NodeType type_
	cstr value
	cstr value_type

	function(LiteralExpr node, int depth) LiteralExpr::print -> void does
		printf("LiteralExpr: type=%s, value=%s\n", node.value_type, node.value)
	return

	function(EleList eles) LiteralExpr::create -> LiteralExpr does
		LiteralExpr new = malloc(@sizeof(LiteralExpr)@)|LiteralExpr
		new.value=eles:get(0):t().text
		if eles:get(0):t().type_.name=="T_INT_LITERAL" do
			new.value_type="int"
		elif eles:get(0):t().type_.name=="T_FLOAT_LITERAL" do
			new.value_type="float"
		else do
			new.value_type="cstr"
		done
	return new

	function(EleList eles) LiteralExpr::match -> int does
	return ((eles:get(0):t().type_.name=="T_INT_LITERAL")+\
		    (eles:get(0):t().type_.name=="T_FLOAT_LITERAL")+\
		    (eles:get(0):t().type_.name=="T_STRING_LITERAL"))|int

	function() LiteralExpr::impl -> NodeType does
	return NodeType::new("LiteralExpr")\
					:set_printer(LiteralExpr::print |NodePrinter)\
					:set_creator(LiteralExpr::create|NodeCreator)\
					:set_matcher(LiteralExpr::match |NodeMatcher)\
					:matches(1):matches_only_tokens():addtype("ValueExpression")
endtype

type DeclExpr is packed
	NodeType type_
	cstr name

	function(DeclExpr node, int depth) DeclExpr::print -> void does
		printf("DeclExpr: '%s'\n", node.name)
	return

	function(EleList eles) DeclExpr::create -> DeclExpr does
		DeclExpr new = malloc(@sizeof(DeclExpr)@)|DeclExpr
		new.name=eles:get(0):t().text
	return new

	function(EleList eles) DeclExpr::match -> int does
	return (eles:get(0):t().type_.name=="T_VAR_DECL")|int

	function() DeclExpr::impl -> NodeType does
	return NodeType::new("DeclExpr")\
					:set_printer(DeclExpr::print |NodePrinter)\
					:set_creator(DeclExpr::create|NodeCreator)\
					:set_matcher(DeclExpr::match |NodeMatcher)\
					:matches(1):matches_only_tokens():addtype("IdentifierExpression")
endtype

type GroupingExpr is packed
	NodeType type_
	Node contents

	function(GroupingExpr node, int depth) GroupingExpr::print -> void does
		printf("GroupingExpr: ")
		node.contents:print(depth+1)
	return

	function(EleList eles) GroupingExpr::create -> GroupingExpr does
		GroupingExpr new = malloc(@sizeof(GroupingExpr)@)|GroupingExpr
		new.contents=eles:get(1):n()
	return new

	function(EleList eles) GroupingExpr::match -> int does
		if (-eles:get(0).is_token):or(\
		     eles:get(1).is_token):or(\
		    -eles:get(2).is_token) do
			return 0
		done

		if (eles:get(0):t().type_.name!="T_PAREN_OPEN"):or(\
			eles:get(2):t().type_.name!="T_PAREN_CLOSE"):or(\
		   -eles:get(1):n():is_a("ValueExpression")) do
			return 0
		done

		if parse::lookahead_is_possibly_function(eles) do
			return 0
		done
	return 3

	function() GroupingExpr::impl -> NodeType does
	return NodeType::new("GroupingExpr")\
					:set_printer(GroupingExpr::print |NodePrinter)\
					:set_creator(GroupingExpr::create|NodeCreator)\
					:set_matcher(GroupingExpr::match |NodeMatcher)\
					:matches(3):addtype("Tuple"):addtype("ValueExpression")
endtype

type TupleEndFragment is packed
	NodeType type_
	Node element

	function(TupleEndFragment node, int depth) TupleEndFragment::print -> void does
		printf("TupleEndFragment, element=")
		node.element:print(depth+1)
	return

	function(EleList eles) TupleEndFragment::create -> TupleEndFragment does
		TupleEndFragment new = malloc(@sizeof(TupleEndFragment)@)|TupleEndFragment
		new.element=eles:get(1):n()
	return new

	function(EleList eles) TupleEndFragment::match -> int does
		if (-eles:get(0).is_token):or(\
		     eles:get(1).is_token):or(\
		    -eles:get(2).is_token) do
			return 0
		done

		if (eles:get(0):t().type_.name!="T_COMMA"):or(\
			eles:get(2):t().type_.name!="T_PAREN_CLOSE"):or(\
		   -eles:get(1):n():is_a("ValueExpression")) do
			return 0
		done
	return 3

	function() TupleEndFragment::impl -> NodeType does
	return NodeType::new("TupleEndFragment")\
					:set_printer(TupleEndFragment::print |NodePrinter)\
					:set_creator(TupleEndFragment::create|NodeCreator)\
					:set_matcher(TupleEndFragment::match |NodeMatcher)\
					:matches(3):addtype("TupleFragment")
endtype

type TupleMidFragment is packed
	NodeType type_
	List elements

	function(TupleMidFragment node, int depth) TupleMidFragment::print -> void does
		printf("TupleMidFragment: (Length=%i)\n", node.elements.len)
		int i=0
		while i<node.elements.len do
			parse::indent(depth)
			printf("|%i- ", i)
			node.elements:get_Node(i):print(depth+1)
			i+=1
		done
	return

	function(EleList eles) TupleMidFragment::create -> TupleMidFragment does
		TupleMidFragment new = malloc(@sizeof(TupleMidFragment)@)|TupleMidFragment
		if eles:get(2):n():is_a("TupleEndFragment") do
			new.elements=List::new()
			new.elements:append_Node(eles:get(1):n())
			new.elements:append_Node((eles:get(2):n()|TupleEndFragment).element)
		else do
			new.elements=(eles:get(2):n()|TupleMidFragment).elements
			new.elements:insert(0, eles:get(1):n()|ptr)
		done
	return new

	function(EleList eles) TupleMidFragment::match -> int does
		if (-eles:get(0).is_token):or(\
		     eles:get(1).is_token):or(\
		     eles:get(2).is_token) do
			return 0
		done

		if (eles:get(0):t().type_.name!="T_COMMA"):or(\
		   -eles:get(1):n():is_a("ValueExpression")):or(\
		   -eles:get(2):n():is_a("TupleFragment")) do
			return 0
		done
	return 3

	function() TupleMidFragment::impl -> NodeType does
	return NodeType::new("TupleMidFragment")\
					:set_printer(TupleMidFragment::print |NodePrinter)\
					:set_creator(TupleMidFragment::create|NodeCreator)\
					:set_matcher(TupleMidFragment::match |NodeMatcher)\
					:matches(3):addtype("TupleFragment")
endtype

type Tuple is packed
	NodeType type_
	List elements

	function(Tuple node, int depth) Tuple::print -> void does
		printf("Tuple: (Length=%i)\n", node.elements.len)
		int i=0
		while i<node.elements.len do
			parse::indent(depth)
			if i==node.elements.len-1 do
				printf("\\%i- ", i)
			else do
				printf("|%i- ", i)
			done
			node.elements:get_Node(i):print(depth+1)
			i+=1
		done
	return

	function(EleList eles) Tuple::create -> Tuple does
		Tuple new = malloc(@sizeof(Tuple)@)|Tuple
		if eles:get(2):n():is_a("TupleEndFragment") do
			new.elements=List::new()
			new.elements:append_Node(eles:get(1):n())
			new.elements:append_Node((eles:get(2):n()|TupleEndFragment).element)
		else do
			new.elements=(eles:get(2):n()|TupleMidFragment).elements
			new.elements:insert(0, eles:get(1):n()|ptr)
		done
	return new

	function(EleList eles) Tuple::match -> int does
		if (-eles:get(0).is_token):or(\
		     eles:get(1).is_token):or(\
		     eles:get(2).is_token) do
			return 0
		done

		if (eles:get(0):t().type_.name!="T_PAREN_OPEN"):or(\
		   -eles:get(2):n():is_a("TupleFragment")):or(\
		   -eles:get(1):n():is_a("ValueExpression")) do
			return 0
		done
	return 3

	function() Tuple::impl -> NodeType does
	return NodeType::new("Tuple")\
					:set_printer(Tuple::print |NodePrinter)\
					:set_creator(Tuple::create|NodeCreator)\
					:set_matcher(Tuple::match |NodeMatcher)\
					:matches(3)
endtype

type ZeroTuple is packed
	NodeType type_

	function(ZeroTuple node, int depth) ZeroTuple::print -> void does
		printf("ZeroTuple: (Length=0)\n")
	return

	function(EleList eles) ZeroTuple::create -> ZeroTuple does
		ZeroTuple new = malloc(@sizeof(ZeroTuple)@)|ZeroTuple
	return new

	function(EleList eles) ZeroTuple::match -> int does
		if (eles:get(0):t().type_.name!="T_PAREN_OPEN"):or(\
		    eles:get(1):t().type_.name!="T_PAREN_CLOSE") do
			return 0
		done
	return 2

	function() ZeroTuple::impl -> NodeType does
	return NodeType::new("ZeroTuple")\
					:set_printer(ZeroTuple::print |NodePrinter)\
					:set_creator(ZeroTuple::create|NodeCreator)\
					:set_matcher(ZeroTuple::match |NodeMatcher)\
					:matches(2):matches_only_tokens():addtype("Tuple")
endtype

type OneTuple is packed
	NodeType type_
	Node element

	function(OneTuple node, int depth) OneTuple::print -> void does
		printf("OneTuple: (Length=1)\n")
		parse::indent(depth)
		printf("\\- ")
		node.element:print(depth+1)
	return

	function(EleList eles) OneTuple::create -> OneTuple does
		OneTuple new = malloc(@sizeof(OneTuple)@)|OneTuple
		new.element=eles:get(1):n()
	return new

	function(EleList eles) OneTuple::match -> int does
		if (-eles:get(0).is_token):or(\
		     eles:get(1).is_token):or(\
		    -eles:get(2).is_token) do
			return 0
		done

		if (-eles:get(0):t():is_a("T_PAREN_OPEN")):or(\
		    -eles:get(1):n():is_a("ValueExpression")):or(\
		    -eles:get(2):t():is_a("T_PAREN_CLOSE")) do
			return 0
		done
	return 3

	function() OneTuple::impl -> NodeType does
	return NodeType::new("OneTuple")\
					:set_printer(OneTuple::print |NodePrinter)\
					:set_creator(OneTuple::create|NodeCreator)\
					:set_matcher(OneTuple::match |NodeMatcher)\
					:matches(3):addtype("Tuple")
endtype

type CallExpr is packed
	NodeType type_
	Node meth
	List args

	function(CallExpr node, int depth) CallExpr::print -> void does
		printf("CallExpr:\n")
		parse::indent(depth)
		printf("|- Method: ")
		node.meth:print(depth+1)

		parse::indent(depth)
		printf("\- Arguments: (Len=%i)\n", node.args.len)
		int i=0
		while i<node.args.len do
			parse::indent(depth+1)
			if i==node.args.len-1 do
				printf("\\%i- ", i)
			else do
				printf("|%i- ", i)
			done
			node.args:get_Node(i):print(depth+2)
			i+=1
		done
	return

	function(EleList eles) CallExpr::create -> CallExpr does
		CallExpr new = malloc(@sizeof(CallExpr)@)|CallExpr
		new.meth=eles:get(0):n()
		Node args = eles:get(1):n()
		if args:is_a("ZeroTuple") do
			new.args=List::new()
		elif args:is_a("OneTuple") do
			new.args=List::new()
			new.args:append_Node((args|OneTuple).element)
		elif args:is_a("GroupingExpr") do
			new.args=List::new()
			new.args:append_Node((args|GroupingExpr).contents)
		else do
			new.args=(args|Tuple).elements
		done
	return new

	function(EleList eles) CallExpr::match -> int does
		if (-eles:get(0):n():is_a("ValueExpression")):or(\
		    -eles:get(1):n():is_a("Tuple")) do
			return 0
		done

		if parse::lookahead_is_accessor(eles) do
			return 0
		done
	return 2

	function() CallExpr::impl -> NodeType does
	return NodeType::new("CallExpr")\
					:set_printer(CallExpr::print |NodePrinter)\
					:set_creator(CallExpr::create|NodeCreator)\
					:set_matcher(CallExpr::match |NodeMatcher)\
					:matches(2):matches_only_nodes():addtype("ValueExpression")
endtype

type ZeroArgList is packed
	NodeType type_

	function(ZeroArgList node, int depth) ZeroArgList::print -> void does
		printf("ZeroArgList: (Size=0)\n")
	return

	function(EleList eles) ZeroArgList::create -> ZeroArgList does
		ZeroArgList new = malloc(@sizeof(ZeroArgList)@)|ZeroArgList
	return new

	function(EleList eles) ZeroArgList::match -> int does
		if (-eles:get(0):t():is_a("T_ARGLIST_START")):or(\
		    -eles:get(1):t():is_a("T_ARGLIST_END")) do
			return 0
		done
	return 2

	function() ZeroArgList::impl -> NodeType does
	return NodeType::new("ZeroArgList")\
					:set_printer(ZeroArgList::print |NodePrinter)\
					:set_creator(ZeroArgList::create|NodeCreator)\
					:set_matcher(ZeroArgList::match |NodeMatcher)\
					:matches(2):matches_only_tokens():addtype("ArgList")
endtype

type OneArgList is packed
	NodeType type_
	cstr text

	function(OneArgList node, int depth) OneArgList::print -> void does
		printf("OneArgList: (Size=1)\n")
		parse::indent(depth+1)
		printf("\\0- %s\n", node.text)
	return

	function(EleList eles) OneArgList::create -> OneArgList does
		OneArgList new = malloc(@sizeof(OneArgList)@)|OneArgList
		new.text=eles:get(1):t().text
	return new

	function(EleList eles) OneArgList::match -> int does
		if (-eles:get(0):t():is_a("T_ARGLIST_START")):or(\
		    -eles:get(1):t():is_a("T_ARGLIST_ELE")):or(\
		    -eles:get(2):t():is_a("T_ARGLIST_END")) do
			return 0
		done
	return 3

	function() OneArgList::impl -> NodeType does
	return NodeType::new("OneArgList")\
					:set_printer(OneArgList::print |NodePrinter)\
					:set_creator(OneArgList::create|NodeCreator)\
					:set_matcher(OneArgList::match |NodeMatcher)\
					:matches(3):matches_only_tokens():addtype("ArgList")
endtype

type MultiArgListStart is packed
	NodeType type_
	cstr text

	function(MultiArgListStart node, int depth) MultiArgListStart::print -> void does
		printf("MultiArgListStart: (Size=1)\n")
		parse::indent(depth+1)
		printf("\\0- %s\n", node.text)
	return

	function(EleList eles) MultiArgListStart::create -> MultiArgListStart does
		MultiArgListStart new = malloc(@sizeof(MultiArgListStart)@)|MultiArgListStart
		new.text=eles:get(1):t().text
	return new

	function(EleList eles) MultiArgListStart::match -> int does
		if (-eles:get(0):t():is_a("T_ARGLIST_SEP")):or(\
		    -eles:get(1):t():is_a("T_ARGLIST_ELE")):or(\
		    -eles:get(2):t():is_a("T_ARGLIST_END")) do
			return 0
		done
	return 3

	function() MultiArgListStart::impl -> NodeType does
	return NodeType::new("MultiArgListStart")\
					:set_printer(MultiArgListStart::print |NodePrinter)\
					:set_creator(MultiArgListStart::create|NodeCreator)\
					:set_matcher(MultiArgListStart::match |NodeMatcher)\
					:matches(3):matches_only_tokens():addtype("MultiArgListFragment")
endtype

type MultiArgListExt is packed
	NodeType type_
	List args

	function(MultiArgListExt node, int depth) MultiArgListExt::print -> void does
		printf("MultiArgListExt: (Size=%i)\n", node.args.len)
		int i=0
		while i<node.args.len do
			parse::indent(depth+1)
			if i==node.args.len-1 do
				printf("\\%i- %s\n", i, node.args:get(i))
			else do
				printf("|%i- %s\n", i, node.args:get(i))
			done
			i+=1
		done
	return

	function(EleList eles) MultiArgListExt::create -> MultiArgListExt does
		MultiArgListExt new = malloc(@sizeof(MultiArgListExt)@)|MultiArgListExt
		Node ele = eles:get(2):n()
		if ele:is_a("MultiArgListStart") do
			new.args=List::new()
			new.args:append(eles:get(1):t().text)
			new.args:append((eles:get(2):n()|MultiArgListStart).text)
		else do #it's a MultiArgListExt
			new.args=(ele|MultiArgListExt).args
			new.args:insert(0, eles:get(1):t().text)
		done
	return new

	function(EleList eles) MultiArgListExt::match -> int does
		if (-eles:get(0).is_token):or(\
			-eles:get(1).is_token):or(\
			 eles:get(2).is_token) do
			return 0
		done

		if (-eles:get(0):t():is_a("T_ARGLIST_SEP")):or(\
		    -eles:get(1):t():is_a("T_ARGLIST_ELE")):or(\
		    -eles:get(2):n():is_a("MultiArgListFragment")) do
			return 0
		done
	return 3

	function() MultiArgListExt::impl -> NodeType does
	return NodeType::new("MultiArgListExt")\
					:set_printer(MultiArgListExt::print |NodePrinter)\
					:set_creator(MultiArgListExt::create|NodeCreator)\
					:set_matcher(MultiArgListExt::match |NodeMatcher)\
					:matches(3):addtype("MultiArgListFragment")
endtype

type MultiArgList is packed
	NodeType type_
	List args

	function(MultiArgList node, int depth) MultiArgList::print -> void does
		printf("MultiArgList: (Size=%i)\n", node.args.len)
		int i=0
		while i<node.args.len do
			parse::indent(depth+1)
			if i==node.args.len-1 do
				printf("\\%i- %s\n", i, node.args:get(i))
			else do
				printf("|%i- %s\n", i, node.args:get(i))
			done
			i+=1
		done
	return

	function(EleList eles) MultiArgList::create -> MultiArgList does
		MultiArgList new = malloc(@sizeof(MultiArgList)@)|MultiArgList
		Node ele = eles:get(2):n()
		if ele:is_a("MultiArgListStart") do
			new.args=List::new()
			new.args:append(eles:get(1):t().text)
			new.args:append((eles:get(2):n()|MultiArgListStart).text)
		else do #it's a MultiArgList
			new.args=(ele|MultiArgList).args
			new.args:insert(0, eles:get(1):t().text)
		done
	return new

	function(EleList eles) MultiArgList::match -> int does
		if (-eles:get(0).is_token):or(\
			-eles:get(1).is_token):or(\
			 eles:get(2).is_token) do
			return 0
		done

		if (-eles:get(0):t():is_a("T_ARGLIST_START")):or(\
		    -eles:get(1):t():is_a("T_ARGLIST_ELE")):or(\
		    -eles:get(2):n():is_a("MultiArgListFragment")) do
			return 0
		done
	return 3

	function() MultiArgList::impl -> NodeType does
	return NodeType::new("MultiArgList")\
					:set_printer(MultiArgList::print |NodePrinter)\
					:set_creator(MultiArgList::create|NodeCreator)\
					:set_matcher(MultiArgList::match |NodeMatcher)\
					:matches(3):addtype("ArgList")
endtype

type FunctionDeclHead is packed
	NodeType type_
	List args
	cstr name
	cstr ret_type

	function(FunctionDeclHead node, int depth) FunctionDeclHead::print -> void does
		printf("FunctionDeclHead: Name='%s' Type='%s' Nargs=%i\n", node.name, node.ret_type, node.args.len)
		int i=0
		while i<node.args.len do
			parse::indent(depth+1)
			if i==node.args.len-1 do
				printf("\\%i- %s\n", i, node.args:get(i))
			else do
				printf("|%i- %s\n", i, node.args:get(i))
			done
			i+=1
		done
	return

	function(EleList eles) FunctionDeclHead::create -> FunctionDeclHead does
		FunctionDeclHead new = malloc(@sizeof(FunctionDeclHead)@)|FunctionDeclHead
		new.name=eles:get(2):t().text
		new.ret_type=eles:get(4):t().text

		Node args = eles:get(1):n()
		if args:is_a("ZeroArgList") do
			new.args=List::new()
		elif args:is_a("OneArgList") do
			new.args=List::new()
			new.args:append((eles:get(1):n()|OneArgList).text)
		else do #it's a MultiArgList
			new.args=(eles:get(1):n()|MultiArgList).args
		done
	return new

	function(EleList eles) FunctionDeclHead::match -> int does
		#T_FUNCTIONDECL ArgList T_FUNCTIONDECL_NAME T_FUNCTIONDECL_RETURN T_FUNCTIONDECL_RETURN_TY
		#...T_FUNCTIONDECL_DOES
		if (-eles:get(0).is_token):or(\
			 eles:get(1).is_token):or(\
			-eles:get(2).is_token):or(\
			-eles:get(3).is_token):or(\
			-eles:get(4).is_token):or(\
			-eles:get(5).is_token) do
			return 0
		done

		if (-eles:get(0):t():is_a("T_FUNCTIONDECL")):or(\
		    -eles:get(1):n():is_a("ArgList")):or(\
		    -eles:get(2):t():is_a("T_FUNCTIONDECL_NAME")):or(\
		    -eles:get(3):t():is_a("T_FUNCTIONDECL_RETURN")):or(\
		    -eles:get(4):t():is_a("T_FUNCTIONDECL_RETURN_TY")):or(\
		    -eles:get(5):t():is_a("T_FUNCTIONDECL_DOES")) do
			return 0
		done
	return 6

	function() FunctionDeclHead::impl -> NodeType does
	return NodeType::new("FunctionDeclHead")\
					:set_printer(FunctionDeclHead::print |NodePrinter)\
					:set_creator(FunctionDeclHead::create|NodeCreator)\
					:set_matcher(FunctionDeclHead::match |NodeMatcher)\
					:matches(6)
endtype

type ReturnExpr is packed
	NodeType type_
	bool is_void
	Node value

	function(ReturnExpr node, int depth) ReturnExpr::print -> void does
		printf("ReturnExpr: ")
		if node.is_void do
			printf("<void>\n")
		else do
			node.value:print(depth+1)
		done
	return

	function(EleList eles) ReturnExpr::create -> ReturnExpr does
		ReturnExpr new = malloc(@sizeof(ReturnExpr)@)|ReturnExpr
		new.is_void=true
		if eles:in_slice()>1 do
			if -eles:get(1).is_token do
				new.is_void=-eles:get(1):n():is_a("ValueExpression")
			done
		done

		if -new.is_void do
			new.value=eles:get(1):n()
		done
	return new

	function(EleList eles) ReturnExpr::match -> int does
		if (-eles:get(0).is_token) do
			return 0
		done

		if (eles:get(0):t().type_.name!="T_RETURN") do
			return 0
		done

		if eles:in_slice()>1 do
			if -eles:get(1).is_token do
				if eles:get(1):n():is_a("ValueExpression") do
					return 2
				done
			done
		done
	return 1

	function() ReturnExpr::impl -> NodeType does
	return NodeType::new("ReturnExpr")\
					:set_printer(ReturnExpr::print |NodePrinter)\
					:set_creator(ReturnExpr::create|NodeCreator)\
					:set_matcher(ReturnExpr::match |NodeMatcher)\
					:matches(1):addtype("Expression")
endtype

type SepExpr is packed
	NodeType type_
	int consumed

	function(SepExpr node, int depth) SepExpr::print -> void does
		printf("SepExpr (Consumed=%i)\n", node.consumed)
	return

	function(EleList eles) SepExpr::create -> SepExpr does
		SepExpr new = malloc(@sizeof(SepExpr)@)|SepExpr
		new.consumed=1
		if eles:in_slice()>1 do
			if eles:get(1).is_token do
				if eles:get(1):t():is_a("T_ENDOFSTATEMENT") do
					if -eles:get(0).is_token do
						if eles:get(0):n():is_a("SepExpr") do
							new.consumed=(eles:get(0):n()|SepExpr).consumed+1
						done
					done
				done
			done
		done
	return new

	function(EleList eles) SepExpr::match -> int does
		if eles:in_slice()>1 do
			if eles:get(1).is_token do
				if eles:get(1):t():is_a("T_ENDOFSTATEMENT") do
					if -eles:get(0).is_token do
						if eles:get(0):n():is_a("SepExpr") do
							return 2
						done
					done
				done
			done
		done

		if (-eles:get(0).is_token) do
			return 0
		done

		if (eles:get(0):t().type_.name!="T_ENDOFSTATEMENT") do
			return 0
		done

		if eles:get_lookahead().is_token do
			if eles:get_lookahead():t():is_a("T_ENDOFSTATEMENT") do
				return 0 #Don't match the last in a series of ends, wait for the first and collapse them all
			done
		done
	return 1

	function() SepExpr::impl -> NodeType does
	return NodeType::new("SepExpr")\
					:set_printer(SepExpr::print |NodePrinter)\
					:set_creator(SepExpr::create|NodeCreator)\
					:set_matcher(SepExpr::match |NodeMatcher)\
					:matches(1):addtype("Expression")
endtype

type FunctionBody is packed
	NodeType type_
	List statements

	function(FunctionBody node, int depth) FunctionBody::print -> void does
		printf("FunctionBody: (N_Statements=%i)\n", node.statements.len)
		int i=0
		while i<node.statements.len do
			parse::indent(depth+1)
			if i==node.statements.len-1 do
				printf("\\%i- ", i)
				node.statements:get_Node(i):print(depth+2)
			else do
				printf("|%i- ", i)
				node.statements:get_Node(i):print(depth+2)
			done
			i+=1
		done
	return

	function(EleList eles) FunctionBody::create -> FunctionBody does
		FunctionBody new = malloc(@sizeof(FunctionBody)@)|FunctionBody
		if eles:in_slice()>2 do
			if eles:get(1):n():is_a("Expression") do
				if -eles:get(2).is_token do
					if eles:get(2):n():is_a("FunctionBody") do
						new.statements=(eles:get(2):n()|FunctionBody).statements
						new.statements:insert(0, eles:get(1):n()|ptr)
					done
				done
			done
		done
		if eles:get(1):n():is_a("ReturnExpr") do
			new.statements=List::new()
			new.statements:append_Node(eles:get(1):n())
		done
	return new

	function(EleList eles) FunctionBody::match -> int does
		if (eles:get(0).is_token) do
			return 0
		done

		if -eles:get(0):n():is_a("SepExpr") do
			return 0
		done

		if eles:get(1).is_token do
			return 0
		done

		if eles:in_slice()>2 do
			if eles:get(1):n():is_a("Expression") do
				if -eles:get(2).is_token do
					if eles:get(2):n():is_a("FunctionBody") do
						return 3
					done
				done
			done
		done
		if eles:get(1):n():is_a("ReturnExpr") do
			return 2
		done
	return 0

	function() FunctionBody::impl -> NodeType does
	return NodeType::new("FunctionBody")\
					:set_printer(FunctionBody::print |NodePrinter)\
					:set_creator(FunctionBody::create|NodeCreator)\
					:set_matcher(FunctionBody::match |NodeMatcher)\
					:matches(2)
endtype

type FunctionDecl is packed
	NodeType type_
	FunctionDeclHead head
	FunctionBody body

	function(FunctionDecl node, int depth) FunctionDecl::print -> void does
		printf("FunctionDecl:\n")
		parse::indent(depth+1)
		printf("|- Head: ")
		(node.head|Node):print(depth+2)
		parse::indent(depth+1)
		printf("\\- Body: ")
		(node.body|Node):print(depth+2)
	return

	function(EleList eles) FunctionDecl::create -> FunctionDecl does
		FunctionDecl new = malloc(@sizeof(FunctionDecl)@)|FunctionDecl
		new.head=eles:get(0):n()|FunctionDeclHead
		new.body=eles:get(1):n()|FunctionBody
	return new

	function(EleList eles) FunctionDecl::match -> int does

		if (-eles:get(0):n():is_a("FunctionDeclHead")):or(\
		    -eles:get(1):n():is_a("FunctionBody")) do
			return 0
		done
	return 2

	function() FunctionDecl::impl -> NodeType does
	return NodeType::new("FunctionDecl")\
					:set_printer(FunctionDecl::print |NodePrinter)\
					:set_creator(FunctionDecl::create|NodeCreator)\
					:set_matcher(FunctionDecl::match |NodeMatcher)\
					:matches(2):matches_only_nodes()
endtype

type CastExpr is packed
	NodeType type_
	Node value
	cstr target

	function(CastExpr node, int depth) CastExpr::print -> void does
		printf("CastExpr (Target='%s')\n", node.target)

		parse::indent(depth)
		printf("\- Value: ")
		node.value:print(depth+1)
	return

	function(EleList eles) CastExpr::create -> CastExpr does
		CastExpr new = malloc(@sizeof(CastExpr)@)|CastExpr
		new.value=eles:get(0):n()
		new.target=(eles:get(2):n()|NameExpr).name
	return new

	function(EleList eles) CastExpr::match -> int does
		if eles:get(0).is_token:or(\
		  -eles:get(1).is_token):or(\
		   eles:get(2).is_token) do
			return 0
		done

		if (eles:get(1):t().type_.name!="T_CAST"):or(\
		   -eles:get(0):n():is_a("ValueExpression")):or(\
		   -eles:get(2):n():is_a("NameExpr")) do
			return 0
		done

		if parse::lookahead_is_accessor(eles) do
			return 0
		done

		if parse::lookahead_is_possibly_function(eles) do
			return 0 #Don't turn a(1)+2 into a,(1)+2
		done

		if eles:get_lookahead().is_token do
			if eles:get_lookahead():t():is_a("T_CAST") do
				return 0
			done
		done
	return 3

	function() CastExpr::impl -> NodeType does
	return NodeType::new("CastExpr")\
					:set_printer(CastExpr::print |NodePrinter)\
					:set_creator(CastExpr::create|NodeCreator)\
					:set_matcher(CastExpr::match |NodeMatcher)\
					:matches(3):addtype("ValueExpression")
endtype

type IndexExpr is packed
	NodeType type_
	Node value
	Node array

	function(IndexExpr node, int depth) IndexExpr::print -> void does
		printf("IndexExpr\n")
		parse::indent(depth)
		printf("|- Array: ")
		node.array:print(depth+1)
		parse::indent(depth)
		printf("\\- Value: ")
		node.value:print(depth+1)
	return

	function(EleList eles) IndexExpr::create -> IndexExpr does
		IndexExpr new = malloc(@sizeof(IndexExpr)@)|IndexExpr
		new.array=eles:get(0):n()
		new.value=eles:get(2):n()
	return new

	function(EleList eles) IndexExpr::match -> int does
		if eles:get(0).is_token:or(\
		  -eles:get(1).is_token):or(\
		   eles:get(2).is_token):or(\
		  -eles:get(3).is_token) do
			return 0
		done

		if (eles:get(1):t().type_.name!="T_BRACKET_OPEN"):or(\
		    eles:get(3):t().type_.name!="T_BRACKET_CLOSE"):or(\
		    -eles:get(0):n():is_a("ValueExpression")):or(\
		    -eles:get(2):n():is_a("ValueExpression")) do
			return 0
		done

		if parse::lookahead_is_accessor(eles) do
			return 0
		done

		if parse::lookahead_is_possibly_function(eles) do
			return 0
		done
	return 4

	function() IndexExpr::impl -> NodeType does
	return NodeType::new("IndexExpr")\
					:set_printer(IndexExpr::print |NodePrinter)\
					:set_creator(IndexExpr::create|NodeCreator)\
					:set_matcher(IndexExpr::match |NodeMatcher)\
					:matches(4):addtype("IdentifierExpression")
endtype

function() parse::init -> void does
	List l=List::new()

	l:append_NodeType(NameExpr::impl())
	l:append_NodeType(DeclExpr::impl())
	l:append_NodeType(AccessorExpr::impl())

	l:append_NodeType(LiteralExpr::impl())
	
	l:append_NodeType(GroupingExpr::impl())
	l:append_NodeType(BinOpExpr::impl())
	l:append_NodeType(UnOpExpr::impl())
	l:append_NodeType(CastExpr::impl())
	l:append_NodeType(IndexExpr::impl())

	l:append_NodeType(CallExpr::impl())

	l:append_NodeType(AssignmentExpr::impl())
	l:append_NodeType(ReturnExpr::impl())

	l:append_NodeType(TupleEndFragment::impl())
	l:append_NodeType(TupleMidFragment::impl())
	l:append_NodeType(Tuple::impl())
	l:append_NodeType(ZeroTuple::impl())

	l:append_NodeType(ZeroArgList::impl())
	l:append_NodeType(OneArgList::impl())
	l:append_NodeType(MultiArgListStart::impl())
	l:append_NodeType(MultiArgListExt::impl())
	l:append_NodeType(MultiArgList::impl())
	l:append_NodeType(FunctionDeclHead::impl())

	l:append_NodeType(FunctionBody::impl())
	l:append_NodeType(FunctionDecl::impl())

	l:append_NodeType(SepExpr::impl())

	l:append_NodeType(OneTuple::impl()) #Fallback matching case for one-arg function calls

	parse_node_types=l
return

function() parse::show_types -> void does
	int p=0
	int i
	NodeType t
	while p<parse_node_types.len do
		t=parse_node_types:get(p)|NodeType
		printf("\n%s%s:", t.name, " "*(20-t.name:len()))
		if t.things_i_am|ptr!=null do
			i=t.things_i_am.len-1
			while i>-1 do
				printf(" %s%s", t.things_i_am:get(i)|cstr, " "*(25-(t.things_i_am:get(i)|cstr):len()))
				i-=1
			done
		done
		printf(" %s", t.name)
		p+=1
	done
	printf("\n")
return