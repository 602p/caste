<#type ImportStmt is packed
	NodeType type_
	cstr name

	function(ImportStmt node, int depth) ImportStmt::print -> void does
		printf("ImportStmt: '%s'\n", node.name)
	return

	function(EleList eles) ImportStmt::create -> ImportStmt does
		ImportStmt new = malloc(@sizeof(ImportStmt)@)|ImportStmt
		new.name=eles:get(0):t().text
	return new

	function(EleList eles) ImportStmt::match -> int does
	return (eles:get(0):t().type_.name=="T_IMPORT")|int

	function() ImportStmt::impl -> NodeType does
	return NodeType::new("ImportStmt")\
					:set_printer(ImportStmt::print |NodePrinter)\
					:set_creator(ImportStmt::create|NodeCreator)\
					:set_matcher(ImportStmt::match |NodeMatcher)\
					:matches(1):matches_only_tokens():addtype("ValueExpression")
endtype#>

List already_loaded_cache

type ImportStmt is packed
	NodeType type_
	cstr name
	cstr path
	EleList statements

	function(ImportStmt node, int depth) ImportStmt::print -> void does
		printf("ImportStmt: '%s' from %s\n", node.name, node.path)
		node.statements:print_depth(depth)
	return

	function(EleList eles) ImportStmt::create -> ImportStmt does
		ImportStmt new = malloc(@sizeof(ImportStmt)@)|ImportStmt
		new.name=eles:get(0):t().text
		cstr path
		bool is_abs_path=false
		if new.name:contains("\x22") do
			is_abs_path=true
			int start=new.name:find("\x22")
			int end=new.name:offset(start+1):find("\x22")
			path=new.name:substr(start+1, end)
		else do
			path=new.name:substr(new.name:find(" ")+1,new.name:len()-(new.name:find(" ")+1))
		done
		if -is_abs_path do
			if File::exists("/home/louis/Documents/orth/shoc/src/"+path+".ort") do
				path="/home/louis/Documents/orth/shoc/src/"+path+".ort"
			else do
				path="/home/louis/Documents/orth/lib/"+path+".ort"
			done
		done
		new.path=path
		if already_loaded_cache|ptr==null do
			already_loaded_cache=List::new()
		done
		int i=0
		while i<already_loaded_cache.len do
			if (already_loaded_cache:get(i)|cstr)==path do
				new.statements=EleList::from(List::new())
				printf("Skipping %s, already loaded\n", path)
				return new
			done
			i+=1
		done
		already_loaded_cache:append(path)
		printf("Loading Path %s\n", path)
		File fd = File::open(path, "r")
		cstr contents=fd:readall()
		List tokens = lex::tokenize(contents)
		new.statements=parse::parse(tokens, contents)
	return new

	function(EleList eles) ImportStmt::match -> int does
	return (eles:get(0):t().type_.name=="T_IMPORT")|int

	function() ImportStmt::impl -> NodeType does
	return NodeType::new("ImportStmt")\
					:set_printer(ImportStmt::print |NodePrinter)\
					:set_creator(ImportStmt::create|NodeCreator)\
					:set_matcher(ImportStmt::match |NodeMatcher)\
					:matches(1):matches_only_tokens():addtype("ValueExpression")
endtype
