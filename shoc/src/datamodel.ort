int VOID #0
int S_INT #1
int U_INT #2
int FLOAT #3
int POINTER #4
int F_PTR #5
int STRUCT #6

function(int variety) datamodel::variety_to_name -> cstr does
	if variety==0 do
		return "VOID"
	elif variety==1 do
		return "S_INT"
	elif variety==2 do
		return "U_INT"
	elif variety==3 do
		return "FLOAT"
	elif variety==4 do
		return "POINTER"
	elif variety==5 do
		return "F_PTR"
	elif variety==6 do
		return "STRUCT"
	done
	shoc::bail_out("datamodel::variety_to_name called on invalid variety: "+variety:str())
return ""

type TypedVar is
	cstr name
	OType type_

	function(cstr name, OType type_) TypedVar::new -> TypedVar does
		TypedVar new = malloc(@sizeof(TypedVar)@)|TypedVar
		new.name=name
		new.type_=type_
	return new

	function(cstr decl_string, Project proj) TypedVar::from_decl -> TypedVar does
		cstr ty = decl_string:substr(0, decl_string:find(" "))
		int i=decl_string:find(" ")
		while decl_string[i]:in(" \t") do
			i+=1
		done
		cstr name = decl_string:offset(i)
	return TypedVar::new(name, proj:get_type(ty))
endtype

function(List l, TypedVar v) List:append_TypedVar -> void does
	l:append(v|ptr)
return

function(List l, OType v) List:append_OType -> void does
	l:append(v|ptr)
return

function(List l, int i) List:get_TypedVar -> TypedVar does
return l:get(i)|TypedVar

function(List l, int i) List:get_OType -> OType does
return l:get(i)|OType

type OType is packed
	int variety
	cstr name
	Project proj

	function(OType t) OType:is_primitive -> bool does
	return t.variety<5

	function(OType t) OType:is_fptr -> bool does
	return t.variety==5

	function(OType t) OType:is_struct -> bool does
	return t.variety==6

	function(OType t) OType:as_primitive -> PrimitiveOType does
	return t|PrimitiveOType

	function(OType t) OType:as_struct -> StructOType does
	return t|StructOType

	function(OType t) OType:as_fptr -> FPtrOType does
	return t|FPtrOType

	function(OType t) OType:get_size -> int does
		if t:is_primitive() do
			return t:as_primitive():get_size()
		elif t:is_fptr() do
			return t:as_fptr():get_size()
		done
	return t:as_struct():get_size()

	function(OType t, Project p) OType:set_project -> OType does
		t.proj=p
	return t

	function(OType t) OType:print -> void does
		if t:is_primitive() do
			t:as_primitive():print()
		elif t:is_fptr() do
			t:as_fptr():print()
		elif t:is_struct() do
			t:as_struct():print()
		else do
			printf("??? %i\n", t.variety)
		done
	return
endtype

type PrimitiveOType is packed
	int variety
	cstr name
	Project proj
	int size

	function(cstr name, int v, int size) PrimitiveOType::new -> OType does
		PrimitiveOType new = malloc(@sizeof(PrimitiveOType)@)|PrimitiveOType

		new.name=name
		new.variety=v
		new.size=size
	return new|OType

	function(PrimitiveOType t) PrimitiveOType:get_size -> int does
	return t.size

	function(PrimitiveOType t) PrimitiveOType:print -> void does
		printf("%i P %s\t", t.variety, datamodel::variety_to_name(t.variety))
		prints_tab(t.name, 30)
		printf("%i bits\n", t:get_size())
	return
endtype

type FPtrOType is packed
	int variety
	cstr name
	Project proj
	List args
	OType return_value

	function(cstr name, OType return_value, List args) FPtrOType::new -> OType does
		FPtrOType new = malloc(@sizeof(FPtrOType)@)|FPtrOType

		new.name=name
		new.args=args
		new.variety=F_PTR
		new.return_value=return_value
	return new|OType

	function(cstr name, OType return_value) FPtrOType::new_varargs -> OType does
		FPtrOType new = malloc(@sizeof(FPtrOType)@)|FPtrOType

		new.name=name
		new.args=null|List
		new.variety=F_PTR
		new.return_value=return_value
	return new|OType

	function(FPtrOType self) FPtrOType:get_size -> int does
	return self.proj.pointer_size

	function(FPtrOType t) FPtrOType:print -> void does
		printf("%i F %s\t", t.variety, datamodel::variety_to_name(t.variety))
		prints_tab(t.name, 30)
		printf("%i bits \t->%s (", t:get_size(), t.return_value.name)
		if t.args|ptr==null do
			printf("...")
		else do
			int i=0
			while i<t.args.len do
				printf("%s", t.args:get_OType(i).name)
				if i!=t.args.len-1 do
					printf(", ")
				done
				i+=1
			done
		done
		printf(")\n")
	return
endtype

type StructOType is packed
	int variety
	cstr name
	Project proj
	bool packed
	List fields

	function(cstr name) StructOType::new -> OType does
		StructOType new = malloc(@sizeof(StructOType)@)|StructOType

		new.name=name
		new.variety=STRUCT
		new.fields=List::new()
		new.packed=false
	return new|OType

	function(StructOType self, cstr decl_string) StructOType:add_field -> void does
		self.fields:append_TypedVar(TypedVar::from_decl(decl_string, self.proj))
	return

	function(StructOType self) StructOType:get_size -> int does
		int i=0
		int sum=0
		while i<self.fields.len do
			if self.fields:get_TypedVar(i).type_:is_struct() do
				sum+=self.proj.pointer_size
			else do
				sum+=self.fields:get_TypedVar(i).type_:get_size()
			done
			i+=1
		done
	return sum

	function(StructOType t) StructOType:print -> void does
		printf("%i S %s\t", t.variety, datamodel::variety_to_name(t.variety))
		prints_tab(t.name, 30)
		printf("%i bits \t{", t:get_size())
		int i=0
		while i<t.fields.len do
			printf("%s: %s", t.fields:get_TypedVar(i).name, t.fields:get_TypedVar(i).type_.name)
			if i!=t.fields.len-1 do
				printf(", ")
			done
			i+=1
		done
		printf("}\n")
	return
endtype

function(Project p) shoc::datamodel::init_base -> void does
	VOID=0
	S_INT=1
	U_INT=2
	FLOAT=3
	POINTER=4
	F_PTR=5
	STRUCT=6

	p:add_Type(PrimitiveOType::new("int", S_INT, 4*8))
	p:add_Type(PrimitiveOType::new("short", S_INT, 2*8))
	p:add_Type(PrimitiveOType::new("byte", S_INT, 1*8))
	p:add_Type(PrimitiveOType::new("long", S_INT, 8*8))
	p:add_Type(PrimitiveOType::new("xlong", S_INT, 16*8))

	p:add_Type(PrimitiveOType::new("uint", U_INT, 4*8))
	p:add_Type(PrimitiveOType::new("ushort", U_INT, 2*8))
	p:add_Type(PrimitiveOType::new("ubyte", U_INT, 1*8))
	p:add_Type(PrimitiveOType::new("ulong", U_INT, 8*8))
	p:add_Type(PrimitiveOType::new("uxlong", U_INT, 16*8))

	p:add_Type(PrimitiveOType::new("float", FLOAT, 8*8))

	p:add_Type(PrimitiveOType::new("bool", U_INT, 1))

	p:add_Type(PrimitiveOType::new("ptr", POINTER, p.pointer_size))
	p:add_Type(PrimitiveOType::new("cstr", POINTER, p.pointer_size))

	p:add_Type(PrimitiveOType::new("void", VOID, 0))
return

function(Project p, cstr name) Project:get_type -> OType does
return p.types:get(name)|OType

type Method is
	cstr name
	Project proj
	List args
	bool varargs
	OType return_value
	OType ptr_type
	StrMap locals
	List gir_code
	bool is_extern

	function(Project proj, cstr name, List args, bool varargs, cstr return_value, bool is_extern) Method::new -> Method does
		Method new = malloc(@sizeof(Method)@)|Method
		new.proj=proj
		new.locals=StrMap::new()
		new.name=name
		new.is_extern=is_extern
		new.varargs=varargs

		new.args=List::new()
		new.gir_code=List::new()

		List fptr_type_args=List::new()

		int i=0
		TypedVar tv
		while i<args.len do
			tv=TypedVar::from_decl(args:get(i), proj)
			new.args:append_TypedVar(tv)
			fptr_type_args:append_OType(tv.type_)
			new.locals:set(tv.name, tv.type_|ptr)
			i+=1
		done

		new.return_value=proj:get_type(return_value)

		if new.varargs do
			new.ptr_type=FPtrOType::new_varargs("$fp_"+name, new.return_value)
		else do
			new.ptr_type=FPtrOType::new("$fp_"+name, new.return_value, fptr_type_args)
		done
		proj:add_Type(new.ptr_type)
	return new

	function(Method func, cstr name, OType v) Method:add_local -> void does
		func.locals:set(name, v|ptr)
	return

	function(Method func, cstr name) Method:has_local -> bool does
	return func.locals:contains(name)

	function(Method func, cstr name) Method:get_local -> OType does
	return func.locals:get(name)|OType

	function(Method func) Method:print -> void does
		prints("METH: ")
		prints_tab(func.name, 60)
		prints(" -> ")
		prints_tab(func.return_value.name, 20)
		prints("(")
		int i=0
		while i<func.args.len do
			printf("%s:%s", func.args:get_TypedVar(i).name, func.args:get_TypedVar(i).type_.name)
			if i!=func.args.len-1 do
				printf(", ")
			done
			i+=1
		done
		printf(")\n")
	return

	function(Method func) Method:print_locals -> void does
		int k=0
		while k<func.locals:num_keys() do
			printf("\tLocal: %s - %s\n", func.locals:get_key_by_num(k), (func.locals:get_by_num(k)|OType).name)
			k+=1
		done
	return

	function(Method func) Method:print_gir -> void does
		int k=0
		while k<func.gir_code.len do
			printf("\tGIR: %03i - ", k)
			func.gir_code:get_GIRInst(k):print()
			k+=1
		done
	return
endtype