import lex
import parse
import grammar
import transformers
import datamodel

function(cstr err) shoc::bail_out -> void does
	printf("\n\nshoc::bail_out called, orth::fail traceback follows...\n")
	orth::fail(err)
return

function(bool cond, cstr err) shoc::assert -> void does
	if -cond do
		shoc::bail_out(err)
	done
return

type Project is
	List token_types
	List node_types
	List transformer_passes
	StrMap options

	int pointer_size

	Method curr_method
	cstr   curr_file

	StrMap types
	StrMap methods
	StrMap globals
	List search_path
	List included_files
endtype

function() shoc::get_empty_project -> Project does
	Project p = malloc(@sizeof(Project)@)|Project

	p.token_types = List::new()
	p.node_types = List::new()
	p.transformer_passes = List::new()
	p.options = StrMap::new()
	p.pointer_size=0

	p.curr_method=null|Method
	p.curr_file="?"

	p.types=StrMap::new()
	p.methods=StrMap::new()
	p.globals=StrMap::new()
	p.included_files = List::new()
	p.search_path=List::new()
return p

function(Project p) Project:in_method -> bool does
return p.curr_method|ptr!=null

function(Project p) Project:with_base_tokens -> Project does
	lex::init_default(p.token_types)
return p

function(Project p) Project:with_base_grammar -> Project does
	parse::init_default(p.node_types)
return p

function(Project p) Project:with_base_passes -> Project does
	shoc::transformers::init(p)
return p

function(Project p) Project:with_base_types -> Project does
	shoc::assert(p.pointer_size!=0, "Must set arch before initilizing typing system")
	shoc::datamodel::init_base(p)
return p

function(Project p, List l) Project:with_search_path -> Project does
	p.search_path=l
return p

function(Project p, StrMap l) Project:with_options -> Project does
	p.options=l
return p

function(Project p, int bits) Project:with_arch_bits -> Project does
	p.pointer_size=bits/8
return p

function(Project p, TransformerPass t) Project:add_Transformer -> void does
	p.transformer_passes:append(t|ptr)
	t:set_project(p)
return

function(Project p, OType t) Project:add_Type -> void does
	p.types:set(t.name, t|ptr)
	t:set_project(p)
return

function(Project p, Method m) Project:add_Method -> void does
	p.methods:set(m.name, m|ptr)
return

function(Project p, TypedVar v) Project:add_Global -> void does
	p.globals:set(v.name, v|ptr)
return

function(Project p, cstr s) Project:get_Method -> Method does
return p.methods:get(s)|Method

function(Project p, Node n) Project:run_only_import -> Node does
return (p.transformer_passes:get(0)|TransformerPass):visit(n)

function(Project p, cstr text) Project:process_text -> Node does
	text+="\n"
return p:run_only_import(p:parse(p:tokenize(text), text))

function(Project p, cstr text) Project:process_project -> Node does
	text+="\n"
return p:run_transformers(p:parse(p:tokenize(text), text))