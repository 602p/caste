import lex
import parse
import grammar
import transformers
import datamodel
import generic_ir

Project _project

function(cstr err) shoc::bail_out -> void does
	if _project|ptr!=null do
		if _project.curr_method|ptr !=null do
			printf("Last method: %s\n", _project.curr_method.name)
		done
	done
	printf("\n\nshoc::bail_out called, orth::fail traceback follows...\n")
	orth::fail(err)
return

function(bool cond, cstr err) shoc::assert -> void does
	if -cond do
		shoc::bail_out(err)
	done
return

type Project is
	List token_types
	List node_types
	List transformer_passes
	List gir_types
	StrMap options
	StrMap sources

	int pointer_size

	Method curr_method
	cstr   curr_file
	int    ssa_count

	StrMap types
	StrMap methods
	StrMap globals
	List search_path
	List included_files
endtype

function() shoc::get_empty_project -> Project does
	Project p = malloc(@sizeof(Project)@)|Project
	_project=p

	p.token_types = List::new()
	p.node_types = List::new()
	p.transformer_passes = List::new()
	p.gir_types = List::new()
	p.options = StrMap::new()
	p.sources=StrMap::new()
	p.pointer_size=0

	p.ssa_count=0
	p.curr_method=null|Method
	p.curr_file="?"

	p.types=StrMap::new()
	p.methods=StrMap::new()
	p.globals=StrMap::new()
	p.included_files = List::new()
	p.search_path=List::new()
return p

function(Project p) Project:in_method -> bool does
return p.curr_method|ptr!=null

function(Project p, Method m) Project:enter_method -> void does
	p.curr_method=m
return

function(Project p) Project:exit_method -> void does
	p.curr_method=null|Method
return

function(Project p, cstr s) Project:enter_method_named -> void does
	if p.methods:contains(s) do
		p:enter_method(p:get_Method(s))
	done #Fail silently for early passes
return

function(Project p) Project:with_base_tokens -> Project does
	lex::init_default(p.token_types)
return p

function(Project p) Project:with_base_grammar -> Project does
	parse::init_default(p.node_types)
return p

function(Project p) Project:with_base_passes -> Project does
	shoc::transformers::init(p)
return p

function(Project p) Project:with_base_gir -> Project does
	gir::init(p)
return p

function(Project p) Project:with_base_types -> Project does
	shoc::assert(p.pointer_size!=0, "Must set arch before initilizing typing system")
	shoc::datamodel::init_base(p)
return p

function(Project p, List l) Project:with_search_path -> Project does
	p.search_path=l
return p

function(Project p, StrMap l) Project:with_options -> Project does
	p.options=l
return p

function(Project p, int bits) Project:with_arch_bits -> Project does
	p.pointer_size=bits
return p

function(Project p, TransformerPass t) Project:add_Transformer -> void does
	p.transformer_passes:append(t|ptr)
	t:set_project(p)
return

function(Project p, GIRInstType t) Project:add_GIRInstType -> void does
	p.gir_types:append(t|ptr)
return

function(Project p, OType t) Project:add_Type -> void does
	p.types:set(t.name, t|ptr)
	t:set_project(p)
return

function(Project p, Method m) Project:add_Method -> void does
	p.methods:set(m.name, m|ptr)
return

function(Project p, TypedVar v) Project:add_Global -> void does
	p.globals:set(v.name, v|ptr)
return

function(Project p, cstr s) Project:get_Method -> Method does
return p.methods:get(s)|Method

function(Project p, Node n) Project:run_only_import -> Node does
return (p.transformer_passes:get(0)|TransformerPass):visit(n)

function(Project p, cstr n) Project:get_transformer_pass -> TransformerPass does
	int i=0
	while i<p.transformer_passes.len do
		if (p.transformer_passes:get(i)|TransformerPass).name==n do
			return p.transformer_passes:get(i)|TransformerPass
		done
		i+=1
	done
	shoc::bail_out("Request for nonexistant TransformerPass: "+n)
return null|TransformerPass

function(Project p, cstr n) Project:get_GIRInstType -> GIRInstType does
	int i=0
	while i<p.gir_types.len do
		if (p.gir_types:get(i)|GIRInstType).name==n do
			return p.gir_types:get(i)|GIRInstType
		done
		i+=1
	done
	shoc::bail_out("Request for nonexistant GIRInstType: "+n)
return null|GIRInstType

function(Project p, cstr text, cstr context) Project:process_text -> Node does
	text+="\n"
return p:run_only_import(p:parse(p:tokenize(text, context, p.options:contains("verbose")), text, p.options:contains("verbose")))

function(Project p, cstr flag, cstr msg) Project:cond_warn -> void does
	if p.options:contains(flag) do
		printf("%-20s: %s\n", flag, msg)
	done
return

function(Project p, cstr flag, cstr msg, Node n) Project:cond_warn_in -> void does
	Token anchor = p:get_node_anchor(n)
	if p.options:contains(flag) do
		printf("%-20s: %s. From file '%s', line %i, col %i, (likely) in '%s':\n", flag, msg, anchor.origin_file, anchor.origin_line, anchor.origin_col, anchor.origin_meth)
		lex::print_highlight(p.sources:get(anchor.origin_file), anchor.origin_line, anchor.origin_col)
	done
return

function(Project p, cstr flag, bool do_warn, cstr msg, Node n) Project:cond_warn_in_if -> void does
	if -do_warn do
		return
	done
	p:cond_warn_in(flag, msg, n)
return

function(Project p, cstr msg, Token anchor) Project:fail_in_token -> void does
	printf("Compilation Failure : %s. From file '%s', line %i, col %i, (likely) in '%s':\n", msg, anchor.origin_file, anchor.origin_line, anchor.origin_col, anchor.origin_meth)
	lex::print_highlight(p.sources:get(anchor.origin_file), anchor.origin_line, anchor.origin_col)
	exit(3)
return

function(Project p, cstr msg, Node n) Project:fail_in -> void does
	p:fail_in_token(msg, p:get_node_anchor(n))
return

function(Project p, bool do_fail, cstr msg, Node n) Project:fail_in_if -> void does
	if -do_fail do
		return
	done
	p:fail_in(msg, n)
return

function(Project p, cstr flag, cstr msg) Project:inv_cond_warn -> void does
	if -p.options:contains(flag) do
		printf("%-20s: %s\n", flag, msg)
	done
return