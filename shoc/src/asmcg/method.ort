
#Compute uses + lifetimes
#Run scheduler, assign each to 1st available
#When needing to spill, add new "lifetime" starting at spill with different storage location (stack)
#When reloading, add new "lifetime" starting at load with different storage location (register)
#Generate code
#Emit loads/stores at lifetime boundaries for the same variable

type RegSched is
	int num_regs
	int required_spill_sz
	ptr array

	function(int reg_count) RegSched::new -> RegSched does
		RegSched new = malloc(@sizeof(RegSched)@)|RegSched
		new.num_regs=reg_count
		new.required_spill_sz=0
		new.array=malloc(reg_count*@sizeof(ptr)@)
		int i=0
		while i<reg_count do
			new:set_unused(i)
			i+=1
		done
	return new

	function(RegSched self, int reg) RegSched:is_used -> bool does
	return unbox::int(self.array:offset(reg*@sizeof(ptr)@))!=0

	function(RegSched self, int reg) RegSched:set_unused -> void does
		self.array:offset(reg*@sizeof(ptr)@)|Box_int.val=0
	return

	function(RegSched self, int reg, GIRVar var) RegSched:set -> void does
		self.array:offset(reg*@sizeof(ptr)@)|Box_ptr.val=var|ptr
	return

	function(RegSched self) RegSched:get_unused_reg -> int does
		int i=0
		while i<self.num_regs do
			if -self:is_used(i) do
				return i
			done
			i+=1
		done
	return -1

	function(RegSched self, int var_sz) RegSched:get_next_stack_slot -> int does
		self.required_spill_sz+=var_sz
	return self.required_spill_sz-var_sz
endtype

type Lifetime is
	int start
	int final
	bool has_reg
	int pos #either register ID or stack ID

	function(int start) Lifetime::new -> Lifetime does
		Lifetime new = malloc(@sizeof(Lifetime)@)|Lifetime
		new.start=start
		new.final=start
		new.has_reg=false
		new.pos=-1
	return new

	function(Lifetime t, int reg) Lifetime:set_reg -> Lifetime does
		t.has_reg=true
		t.pos=reg
	return t

	function(Lifetime t, int pos) Lifetime:set_stack -> Lifetime does
		t.has_reg=false
		t.pos=pos
	return t

	function(Lifetime t) Lifetime:has_pos -> bool does
	return t.pos!=-1

	function(Lifetime curr_lifetime) Lifetime:print -> void does
	if curr_lifetime:has_pos() do
			if curr_lifetime.has_reg do
				printf(" r%i ", curr_lifetime.pos)
			else do
				printf("s[%i]", curr_lifetime.pos)
			done
		else do
			printf("?")
		done
	return
endtype

function(List l, Lifetime t) List:append_Lifetime -> void does
	l:append(t|ptr)
return

function(List l, int i) List:get_Lifetime -> Lifetime does
return l:get(i)|Lifetime

type LifetimeManager is
	int first_ssa_var
	int last_ssa_var
	ptr array

	function(int first_ssa_var, int last_ssa_var) LifetimeManager::new -> LifetimeManager does
		LifetimeManager new = malloc(@sizeof(LifetimeManager)@)|LifetimeManager
		new.first_ssa_var=first_ssa_var
		new.last_ssa_var=last_ssa_var

		int sz=((last_ssa_var-first_ssa_var)+1)*@sizeof(ptr)@
		new.array=malloc(sz)
		memset(new.array, 0, sz)
	return new

	function(LifetimeManager self, int i) LifetimeManager:_get_list -> List does
	return unbox::ptr(self.array:offset(i*@sizeof(ptr)@))|List

	function(LifetimeManager self, int i, List l) LifetimeManager:_set_list -> void does
		self.array:offset(i*@sizeof(ptr)@)|Box_ptr.val=l|ptr
	return

	function(LifetimeManager self, int var) LifetimeManager:get_lifetime_list_id -> List does
	return self:_get_list(var-self.first_ssa_var)

	function(LifetimeManager self, GIRVar var) LifetimeManager:get_lifetime_list -> List does
	return self:get_lifetime_list_id(var.ssa_id)

	function(LifetimeManager self, GIRVar var, List l) LifetimeManager:set_lifetime_list -> void does
		self:_set_list(var.ssa_id-self.first_ssa_var, l)
	return

	function(LifetimeManager self, int id) LifetimeManager:contains_id -> bool does
	return self:get_lifetime_list_id(id)|ptr!=null

	function(LifetimeManager self, GIRVar var) LifetimeManager:contains -> bool does
	return self:get_lifetime_list(var)|ptr!=null

	function(LifetimeManager self, GIRVar var, Lifetime l) LifetimeManager:set_new_lifetime -> void does
		List newlist = List::new()
		newlist:append_Lifetime(l)
		self:set_lifetime_list(var, newlist)
	return

	function(LifetimeManager self, int id) LifetimeManager:get_last_lifetime_id -> Lifetime does
		List ll = self:get_lifetime_list_id(id)
	return ll:get_Lifetime(ll.len-1)

	function(LifetimeManager self, GIRVar var) LifetimeManager:get_last_lifetime -> Lifetime does
	return self:get_last_lifetime_id(var.ssa_id)

	function(LifetimeManager self, int id, Lifetime l) LifetimeManager:append_lifetime -> void does
		self:get_lifetime_list_id(id):append_Lifetime(l)
	return

	function(LifetimeManager self) LifetimeManager:num_keys -> int does
	return (self.last_ssa_var-self.first_ssa_var)+1

	function(LifetimeManager self, GIRVar var, int gir_pos) LifetimeManager:get_lifetime_at -> Lifetime does
		int i=0
		List ll = self:get_lifetime_list(var)
		Lifetime l
		while i<ll.len do
			l=ll:get_Lifetime(i)
			if l.start<=gir_pos & l.final>=gir_pos do
				return l
			done
			i+=1
		done
		shoc::bail_out("LifetimeManager did not have assigned lifetime for requested ssa var "+var.ssa_id:str()+" at GIR location "+gir_pos:str())
	return null|Lifetime
endtype

function(ASMProject proj, Method meth) asmcg::emit_method -> void does
	printf("\n\n##############################\nEmitting method %s\n", meth.name)

	List var_uses = List::new()

	List curr_used_list
	int curr_inst_id=0
	int min_id=-1
	int max_id=-1
	while curr_inst_id<meth.gir_code.len do
		curr_used_list=meth.gir_code:get_GIRInst(curr_inst_id):get_used()
		var_uses:append_List(curr_used_list)
		int j=0
		while j<curr_used_list.len do
			if (curr_used_list:get_GIRVar(j).ssa_id<min_id):or(min_id==-1) do
				min_id=curr_used_list:get_GIRVar(j).ssa_id
			done
			if (curr_used_list:get_GIRVar(j).ssa_id>max_id):or(max_id==-1) do
				max_id=curr_used_list:get_GIRVar(j).ssa_id
			done
			j+=1
		done
		curr_inst_id+=1
	done

	LifetimeManager lifetimes = LifetimeManager::new(min_id, max_id)
	GIRInst inst
	
	curr_inst_id=0
	while curr_inst_id<meth.gir_code.len do
		inst=meth.gir_code:get_GIRInst(curr_inst_id)
		curr_used_list=var_uses:get_List(curr_inst_id)
		int curr_used=0
		while curr_used<curr_used_list.len do
			GIRVar curr_var = curr_used_list:get_GIRVar(curr_used)
			if -lifetimes:contains(curr_var) do
				lifetimes:set_new_lifetime(curr_var, Lifetime::new(curr_inst_id))
			else do
				lifetimes:get_last_lifetime(curr_var).final=curr_inst_id
			done
			curr_used+=1
		done
		curr_inst_id+=1
	done

	asmcg::print_alloc_state(meth, lifetimes, var_uses)

	RegSched sched = RegSched::new(2)

	Lifetime curr_lifetime
	curr_inst_id=0
	while curr_inst_id<meth.gir_code.len do
		inst=meth.gir_code:get_GIRInst(curr_inst_id)
		curr_used_list=var_uses:get_List(curr_inst_id)

		int curr_used=0
		while curr_used<curr_used_list.len do
			curr_lifetime=lifetimes:get_last_lifetime(curr_used_list:get_GIRVar(curr_used))
			if curr_lifetime.final==curr_inst_id do #TODO: Enforce that regs are freed before allocating new ones? is this in order?
				if curr_lifetime.has_reg do
					sched:set_unused(curr_lifetime.pos)
				else do
					#TODO: Reload now?
				done
			done
			if curr_lifetime.start==curr_inst_id do
				int reg = sched:get_unused_reg()
				if reg!=-1 do
					curr_lifetime:set_reg(sched:get_unused_reg())
					sched:set(curr_lifetime.pos, curr_used_list:get_GIRVar(curr_used))
				else do

					int spill_search=min_id
					Lifetime curr_search_lifetime
					int best_search_lifetime=-1
					Lifetime best_search_lifetime_ob

					printf("Searching for lifetime to spill... at idx=%i\n", curr_inst_id)

					while spill_search<=max_id do
						if lifetimes:contains_id(spill_search) do
							curr_search_lifetime=lifetimes:get_last_lifetime_id(spill_search)
							if curr_search_lifetime.has_reg do
								if best_search_lifetime==-1 do
									best_search_lifetime_ob=curr_search_lifetime
									best_search_lifetime=spill_search
								elif curr_search_lifetime.final>best_search_lifetime_ob.final do
									best_search_lifetime=spill_search
									best_search_lifetime_ob=curr_search_lifetime
								done
							done
						done
						spill_search+=1
					done

					printf("Decided to spill %i\n", best_search_lifetime)

					int orig_end=best_search_lifetime_ob.final

					best_search_lifetime_ob.final=curr_inst_id
					# printf("b_s_l_o.final=%i\n", best_search_lifetime_ob.final)
					sched:set_unused(best_search_lifetime_ob.pos)

					Lifetime new_lifetime = Lifetime::new(curr_inst_id)
					new_lifetime.final=orig_end
					new_lifetime:set_stack(sched:get_next_stack_slot(1))
					lifetimes:append_lifetime(best_search_lifetime, new_lifetime)

					curr_lifetime:set_reg(sched:get_unused_reg())
					sched:set(curr_lifetime.pos, curr_used_list:get_GIRVar(curr_used))
				done
			done
			curr_used+=1
		done

		curr_inst_id+=1
	done 

	printf("\n\n============================\n\n")
	asmcg::print_alloc_state(meth, lifetimes, var_uses)

	#idea - treat spills as fake physical registers, then can schedule those for minimal scratch space
	#also turns graph-coloring algorithms into finding the smallest k for which the graph is colorable

	printf("\nEmitting assembly...\n")

	asmcg::emit_method_code(proj, meth, lifetimes)
return

function(Method meth, LifetimeManager lifetimes, List var_uses) asmcg::print_alloc_state -> void does
	int curr_inst_id=0
	Lifetime curr_lifetime
	List curr_used_list
	GIRInst inst
	while curr_inst_id<meth.gir_code.len do
		inst=meth.gir_code:get_GIRInst(curr_inst_id)
		curr_used_list=var_uses:get_List(curr_inst_id)
		int i=0
		printf("GIR %02i - ", curr_inst_id)
		inst:print()
		printf(" Uses:")
		while i<curr_used_list.len do
			printf("%i ", curr_used_list:get_GIRVar(i).ssa_id)
			curr_lifetime=lifetimes:get_lifetime_at(curr_used_list:get_GIRVar(i), curr_inst_id)
			
			curr_lifetime:print()
			printf(" ")
			if curr_lifetime.start==curr_inst_id do
				printf("<start> ")
			done
			if curr_lifetime.final==curr_inst_id do
				printf("< end > ")
			done
			printf(", ")
			i+=1
		done
		printf("\n")

		int curr_lifetime_id=lifetimes.first_ssa_var
		while curr_lifetime_id<=lifetimes.last_ssa_var do
			if lifetimes:contains_id(curr_lifetime_id) do
				List curr_ll = lifetimes:get_lifetime_list_id(curr_lifetime_id)
				int curr_ll_pos=0
				while curr_ll_pos<curr_ll.len-1 do
					Lifetime cur_l = curr_ll:get_Lifetime(curr_ll_pos)
					Lifetime next_l = curr_ll:get_Lifetime(curr_ll_pos+1)
					if cur_l.final==curr_inst_id do
						# printf("cur.pos=r%i, next.pos=s[%i]\n", cur_l.pos, next_l.pos)
						# printf("cur.final=%i, next.final=%i\n", cur_l.final, next_l.final)
						# printf("cur.start=%i, next.start=%i\n", cur_l.start, next_l.start)
						printf(" Store/load: %i: ", curr_lifetime_id)
						cur_l:print()
						printf(" -> ")
						next_l:print()
						printf("\n")
					done
					curr_ll_pos+=1
				done
			done
			curr_lifetime_id+=1
		done

		curr_inst_id+=1
	done
return