
function(ASMProject proj, Method meth, LifetimeManager lifetimes) asmcg::emit_method_code -> void does
	ASMMethod out = ASMMethod::new(proj, meth.name)

	out:e_f_enter()

	StrMap locals_addresses = StrMap::new()

	printf("Calculating Frame...\n")

	int locals_sz = 0
	int i=0
	while i<meth.locals:num_keys() do
		
		if meth.locals:get_by_num(i)|OType.variety==STRUCT do
			locals_sz+=8 #Same on 32-bit, keep aligned
		else do
			locals_sz+=meth.locals:get_by_num(i)|OType:get_size()/8
		done
		if locals_sz%8 != 0 do
			locals_sz+=8-(locals_sz%8)
		done
		locals_addresses:set_int(meth.locals:get_key_by_num(i), locals_sz)
		i+=1
	done

	out:e_move_sp(locals_sz)

	printf("Emitting Code...\n")

	int i=0
	while i<meth.gir_code.len do
		asmcg::emit_inst(i, meth.gir_code:get_GIRInst(i), meth, out, lifetimes, locals_addresses)
		i+=1
	done

	proj:add_meth(out)
return

function(int inst_idx, GIRInst inst, Method meth, ASMMethod out, LifetimeManager lifetimes, StrMap locals_addresses) asmcg::emit_inst -> void does
	if inst:is_a("literal") do
		GIRLiteral literal = inst|GIRLiteral
		out:e_set_immediate(lifetimes:get_lifetime_at(literal.out_var, inst_idx).pos, literal.integer_value|int)
	elif inst:is_a("return") do
		GIRReturn return_ = inst|GIRReturn
		if -return_.is_void do
			int ret_reg = lifetimes:get_lifetime_at(return_.value, inst_idx).pos
			if ret_reg!=0 do
				out:e_copy_reg(ret_reg, 0)
			done
		done
		out:e_f_leave()
		out:e_return()
	elif inst:is_a("binop") do
		GIRBinOp binop = inst|GIRBinOp
		int bo_lhs=lifetimes:get_lifetime_at(binop.lhs, inst_idx).pos
		int bo_rhs=lifetimes:get_lifetime_at(binop.rhs, inst_idx).pos
		int bo_out=lifetimes:get_lifetime_at(binop.out_var, inst_idx).pos

		if binop.operator=="+" do
			if bo_out==bo_lhs do
				out:e_add_ip(bo_lhs, bo_rhs)
			elif bo_out==bo_rhs do
				out:e_add_ip(bo_rhs, bo_lhs)
			else do
				out:e_copy_reg(bo_rhs, bo_out)
				out:e_add_ip(bo_out, bo_lhs)
			done
		elif binop.operator=="-" do
			if bo_out==bo_lhs do
				out:e_sub_ip(bo_lhs, bo_rhs)
			else do
				out:e_copy_reg(bo_lhs, bo_out)
				out:e_sub_ip(bo_out, bo_rhs)
			done
		elif binop.operator=="*" do
			#dest is edx:eax always
			if bo_out!=0 do #if we dont want it in eax, save eax
				out:e_push_reg(0)
			done
			#TODO: Don't push edx if not needed
			out:e_push_reg(3)

			if bo_lhs!=0 do
				out:e_copy_reg(bo_lhs, 0)
			done
			
			out:e_mul(bo_rhs)

			out:e_pop_reg(3)

			if bo_out!=0 do
				out:e_copy_reg(0, bo_out)
				out:e_pop_reg(0)
			done
		elif binop.operator=="/" do
			#dest is edx (remainder), eax (quotient) always
			if bo_out!=0 do #if we dont want it in eax, save eax
				out:e_push_reg(0)
			done
			#TODO: Don't push edx if not needed
			out:e_push_reg(3)

			out:e_set_immediate(3, 0) #Clear high dividend

			if bo_lhs!=0 do
				out:e_copy_reg(bo_lhs, 0)
			done
			
			out:e_div(bo_rhs)

			out:e_pop_reg(3)

			if bo_out!=0 do
				out:e_copy_reg(0, bo_out)
				out:e_pop_reg(0)
			done
		else do
			shoc::bail_out("no other ops")
		done
	elif inst:is_a("store") do
		GIRStore store = inst|GIRStore
		out:e_reg_to_memreg_32(lifetimes:get_lifetime_at(store.value, inst_idx).pos, lifetimes:get_lifetime_at(store.location, inst_idx).pos)
	elif inst:is_a("load") do
		GIRLoad load = inst|GIRLoad
		out:e_memreg_to_reg_32(lifetimes:get_lifetime_at(load.location, inst_idx).pos, lifetimes:get_lifetime_at(load.out_var, inst_idx).pos)
	elif inst:is_a("get_local") do
		GIRGetLocal getlocal = inst|GIRGetLocal
		out:e_lea_localaddr(lifetimes:get_lifetime_at(getlocal.out_var, inst_idx).pos, locals_addresses:get_int(getlocal.var_name))
	else do
		shoc::bail_out("no other gir")
	done
return