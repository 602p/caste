
function(BinOpExpr n, TransformerPass p) fold_constants::visit_binop -> Node does
	if n.lhs:is_a("LiteralExpr") & n.rhs:is_a("LiteralExpr") do
		LiteralExpr lhs = n.lhs|LiteralExpr
		LiteralExpr rhs = n.rhs|LiteralExpr
		if (lhs.value_type=="int") & rhs.value_type=="int" do
			int ri=rhs.value:int()
			int li=lhs.value:int()
			if n.op=="+" do
				return LiteralExpr::create_direct("int", (ri+li):str())
			elif n.op=="-" do
				return LiteralExpr::create_direct("int", (li-ri):str())
			elif n.op=="*" do
				return LiteralExpr::create_direct("int", (li*ri):str())
			elif n.op=="/" do
				return LiteralExpr::create_direct("int", (li/ri):str())
			elif n.op==">>" do
				return LiteralExpr::create_direct("int", (li>>ri):str())
			elif n.op=="<<" do
				return LiteralExpr::create_direct("int", (li<<ri):str())
			elif n.op=="==" do
				return LiteralExpr::create_direct("int", (li==ri):str())
			elif n.op=="!=" do
				return LiteralExpr::create_direct("int", (li!=ri):str())
			elif n.op==">" do
				return LiteralExpr::create_direct("int", (li>ri):str())
			elif n.op=="<" do
				return LiteralExpr::create_direct("int", (li<ri):str())
			elif n.op==">=" do
				return LiteralExpr::create_direct("int", (li/ri):str())
			elif n.op=="<=" do
				return LiteralExpr::create_direct("int", (li<=ri):str())
			elif n.op=="&" do
				return LiteralExpr::create_direct("int", (li&ri):str())
			elif n.op=="%" do
				return LiteralExpr::create_direct("int", (li%ri):str())
			done
		elif (lhs.value_type=="float") & rhs.value_type=="float" do
			float rf=rhs.value:float()
			float lf=lhs.value:float()
			if n.op=="+" do
				return LiteralExpr::create_direct("float", (rf+lf):str())
			elif n.op=="-" do
				return LiteralExpr::create_direct("float", (lf-rf):str())
			elif n.op=="*" do
				return LiteralExpr::create_direct("float", (lf*rf):str())
			elif n.op=="/" do
				return LiteralExpr::create_direct("float", (lf/rf):str())
			elif n.op=="==" do
				return LiteralExpr::create_direct("int", (lf==rf):str())
			elif n.op=="!=" do
				return LiteralExpr::create_direct("int", (lf!=rf):str())
			elif n.op==">" do
				return LiteralExpr::create_direct("int", (lf>rf):str())
			elif n.op=="<" do
				return LiteralExpr::create_direct("int", (lf<rf):str())
			elif n.op==">=" do
				return LiteralExpr::create_direct("int", (lf/rf):str())
			elif n.op=="<=" do
				return LiteralExpr::create_direct("int", (lf<=rf):str())
			done
		elif (lhs.value_type=="cstr") & rhs.value_type=="cstr" do
			if n.op=="+" do
				return LiteralExpr::create_direct("cstr", lhs.value+rhs.value)
			done
		done
	done
return n|Node

function() fold_constants::init -> TransformerPass does
return TransformerPass::new("fold_constants")\
       :add_specialization("BinOpExpr", fold_constants::visit_binop|NodeTransformer)