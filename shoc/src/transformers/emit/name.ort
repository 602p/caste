
function(NameExpr n, TransformerPass p) emit_addr::for_name -> GIRVar does
	if p.proj.curr_method:has_local(n.name) do
		return GIRGetLocal::emit(p.proj, p.proj.curr_method:get_local(n.name), n.name)
	done
	shoc::bail_out("Can't resolve name "+n.name)
return null|GIRVar

function(NameExpr n, TransformerPass p) emit_value::for_name -> GIRVar does
	# printf("'%s' req in %s -> %i\n", n.name, p.proj.curr_method.name, (p.proj.curr_method.locals:contains(n.name)|int))
	if p.proj.curr_method.locals:contains(n.name) do
		return GIRLoad::emit(p.proj, p:emit_addr(n|Node))
	done
return GIRGetMethod::emit(p.proj, p.proj:get_Method(n.name))

function(DeclExpr n, TransformerPass p) emit_addr::for_decl -> GIRVar does
	cstr name = TypedVar::from_decl(n.name, p.proj).name
return GIRGetLocal::emit(p.proj, p.proj.curr_method:get_local(name), name)

function(DeclExpr n, TransformerPass p) emit_value::for_decl -> GIRVar does
return GIRLoad::emit(p.proj, p:emit_addr(n|Node))