import strmap
import parse

type NodeTransformer is a function->Node #taking (Node, TransformerPass), returning new node for tree

type TransformerPass is
	cstr   name
	StrMap visitor_map
	ptr    extra_info

	function(cstr name) TransformerPass::new -> TransformerPass does
		TransformerPass new = malloc(@sizeof(TransformerPass)@)|TransformerPass
		new.name=name
		new.visitor_map=StrMap::new()
	return new

	function(TransformerPass self, cstr node_type, NodeTransformer visitor) TransformerPass:add_specialization -> TransformerPass does
		self.visitor_map:set(node_type, visitor|ptr)
	return self

	function(TransformerPass self, ptr info) TransformerPass:set_info -> TransformerPass does
		self.extra_info=info
	return self

	function(TransformerPass self, Node n) TransformerPass:visit_children -> void does
		n:run_transformer_on_children(self)
	return

	function(TransformerPass self, Node n) TransformerPass:visit -> Node does
		self:visit_children(n)
		if self.visitor_map:contains(n.type_.name) do
			ptr entry = self.visitor_map:get(n.type_.name)
			NodeTransformer v = entry|NodeTransformer
			return v(n, self)
		done
	return n
endtype

import transformers
List shoc_transformers

function() transform::init -> void does
	shoc_transformers=List::new()
	shoc::transformers::init(shoc_transformers)
return

function(Node n) shoc::run_transformers -> Node does
	int i=0
	while i<shoc_transformers.len do
		printf("Running transformer pass '%s'\n", (shoc_transformers:get(i)|TransformerPass).name)
		n=(shoc_transformers:get(i)|TransformerPass):visit(n)
		i+=1
	done
return n