type GenericArgs is
	StrMap _args
	List _order

	function() GenericArgs::new -> GenericArgs does
		GenericArgs self = malloc(@sizeof(GenericArgs)@)|GenericArgs
		self._args = StrMap::new()
		self._order = List::new()
	return self

	function(GenericArgs other) GenericArgs::copy -> GenericArgs does
		GenericArgs self = malloc(@sizeof(GenericArgs)@)|GenericArgs
		self._args = StrMap::new()
		self._order = List::new()
		int i=0
		while i<other:len() do
			self:add(other:get_name_for_idx(i), other:get_idx(i))
			i+=1
		done
	return self

	function(GenericArgs self, cstr name, OType arg) GenericArgs:add -> void does
		self._order:append(name)
		self._args:set(name, arg|ptr)
	return

	function(GenericArgs self, cstr name, OType arg) GenericArgs:set -> void does
		self._args:set(name, arg|ptr)
	return

	function(GenericArgs self, cstr name) GenericArgs:add_null -> void does
		self:add(name, null|OType)
	return

	function(GenericArgs self, cstr name) GenericArgs:get_name -> OType does
	return self._args:get(name)|OType

	function(GenericArgs self, int idx) GenericArgs:get_name_for_idx -> cstr does
	return self._order:get(idx)

	function(GenericArgs self, int idx) GenericArgs:get_idx -> OType does
	return self:get_name(self:get_name_for_idx(idx))

	function(GenericArgs self) GenericArgs:len -> int does
	return self._order.len

	function(GenericArgs self, cstr i) GenericArgs:contains -> bool does
	return self._args:contains(i)
endtype

type GType is
	cstr name
	GenericArgs arguments #(map of generic name -> OType OR null if no default)
	bool packed
	List fields #List of TypedVars
	Project proj

	function(Project p, cstr name, bool packed, GenericArgs arguments) GType::new -> GType does
		GType self = malloc(@sizeof(GType)@)|GType
		self.name=name
		self.arguments=arguments
		self.fields = List::new()
		self.packed = packed
		self.proj=p
	return self

	function(GType self, GenericArgs params) GType:apply -> OType does
		cstr mangled_name = self.name+".G_"

		int i=0
		while i<params:len() do
			mangled_name+="A"+params:get_idx(i).name+"Z"
			if i!=params:len()-1 do
				mangled_name+="."
			done
			i+=1
		done

		if self.proj.types:contains(mangled_name) do
			return self.proj:get_type(mangled_name)
		done
		
		StructOType new_t = StructOType::new(mangled_name)|StructOType
		new_t.packed=self.packed
		self.proj:add_Type(new_t|OType)

		i=0
		while i<self.fields.len do
			TypedVar orig_var = self.fields:get_TypedVar(i)
			OType resolved_var = orig_var.type_
			if resolved_var.variety==SYMTYPE do
				resolved_var=params:get_name(resolved_var.name)
			done
			resolved_var=resolved_var:resolve(params)
			new_t:add_field(TypedVar::new(orig_var.name, resolved_var))
			i+=1
		done
	return new_t|OType

	function(GType self) GType:print -> void does
		printf("GType: %s ", self.name)
		if self.packed do
			printf("packed ")
		done
		printf("\n")
		int i=0
		while i<self.fields.len do
			printf(" -field: %s:", self.fields:get_TypedVar(i).name)
			self.fields:get_TypedVar(i).type_:print()
			i+=1
		done
		i=0
		while i<self.arguments:len() do
			printf(" -arg: %s: ", self.arguments:get_name_for_idx(i))
			if self.arguments:get_idx(i)|ptr!=null do
				self.arguments:get_idx(i):print()
			else do
				printf(" [no default]\n")
			done
			i+=1
		done
	return
endtype

type PType is packed
	int variety
	cstr name
	Project proj
	GType generic
	GenericArgs arguments #(map of generic name -> OType OR null if using default)

	function(GType generic, GenericArgs arguments) PType::new -> OType does
		PType self = malloc(@sizeof(PType)@)|PType
		self.generic=generic
		self.arguments=arguments
		self.variety=PTYPE
		self.name="[Generic Of: "+generic.name+": "
		int i=0
		while i<arguments:len() do
			self.name+=arguments:get_idx(i).name
			if i!=arguments:len()-1 do
				self.name+=", "
			done
			i+=1
		done
		self.name+="]"
	return self|OType

	function(PType self, GenericArgs params) PType:resolve -> OType does
		int i=0
		GenericArgs inst_args = GenericArgs::copy(self.arguments)
		while i<self.arguments:len() do
			if self.arguments:get_idx(i).variety==SYMTYPE do
				self.arguments:set(self.arguments:get_name_for_idx(i), params:get_name(self.arguments:get_name_for_idx(i)))
			done
			i+=1
		done
	return self.generic:apply(self.arguments)

	function(PType self) PType:print -> void does
		printf("PType %s\n", self.name)
		int i=0
		while i<self.arguments:len() do
			printf("\t-param: %s: ", self.arguments:get_name_for_idx(i))
			self.arguments:get_idx(i):print()
			i+=1
		done
	return
endtype

type SymType is packed
	int variety
	cstr name
	Project proj

	function(cstr name) SymType::new -> OType does
		SymType self = malloc(@sizeof(SymType)@)|SymType
		self.variety=SYMTYPE
		self.name=name
	return self|OType

	function(SymType self) SymType:print -> void does
		printf("[SymType %s]\n", self.name)
	return
endtype



function(Project proj) generic::implement_generics -> void does
	# printf("Implementing Generics... %i Methods...\n", proj.methods:num_keys())
	int i=0

	while i<proj.methods:num_keys() do
		generic::implement_method(proj, proj.methods:get_by_num(i)|Method)
		i+=1
	done
return

function(Project proj, Method meth) generic::implement_method -> void does
	# printf("Method: %s\n", meth.name)
	int i=0
	while i<meth.locals:num_keys() do
		OType l_type = meth.locals:get_by_num(i)|OType
		meth.locals:set(meth.locals:get_key_by_num(i), l_type:resolve(GenericArgs::new())|ptr)
		i+=1
	done
return

function(FileNode n, TransformerPass p) implement_generics::visit_file -> FileNode does
	generic::implement_generics(p.proj)
return n

function() implement_generics::init -> TransformerPass does
return TransformerPass::new("implement_generics"):no_auto_visit()\
       :add_specialization("FileNode", implement_generics::visit_file|NodeTransformer)