type GenericArgs is
	StrMap _args
	List _order

	function() GenericArgs::new -> GenericArgs does
		GenericArgs self = malloc(@sizeof(GenericArgs)@)|GenericArgs
		self._args = StrMap::new()
		self._order = List::new()
	return self

	function(GenericArgs other) GenericArgs::copy -> GenericArgs does
		GenericArgs self = malloc(@sizeof(GenericArgs)@)|GenericArgs
		self._args = StrMap::new()
		self._order = List::new()
		int i=0
		while i<other:len() do
			self:add(other:get_name_for_idx(i), other:get_idx(i))
			i+=1
		done
	return self

	function(GenericArgs self, cstr name, OType arg) GenericArgs:add -> void does
		self._order:append(name)
		self._args:set(name, arg|ptr)
	return

	function(GenericArgs self, cstr name, OType arg) GenericArgs:set -> void does
		self._args:set(name, arg|ptr)
	return

	function(GenericArgs self, cstr name) GenericArgs:add_null -> void does
		self:add(name, null|OType)
	return

	function(GenericArgs self, cstr name) GenericArgs:get_name -> OType does
	return self._args:get(name)|OType

	function(GenericArgs self, int idx) GenericArgs:get_name_for_idx -> cstr does
	return self._order:get(idx)

	function(GenericArgs self, int idx) GenericArgs:get_idx -> OType does
	return self:get_name(self:get_name_for_idx(idx))

	function(GenericArgs self, int idx, OType v) GenericArgs:set_idx -> void does
		self:set(self:get_name_for_idx(idx), v)
	return

	function(GenericArgs self) GenericArgs:len -> int does
	return self._order.len

	function(GenericArgs self, cstr i) GenericArgs:contains -> bool does
	return self._args:contains(i)
endtype

type GType is packed
	cstr name
	GenericArgs arguments #(map of generic name -> OType OR null if no default)
	bool packed
	List fields #List of TypedVars
	Project proj

	function(Project p, cstr name, bool packed, GenericArgs arguments) GType::new -> GType does
		GType self = malloc(@sizeof(GType)@)|GType
		self.name=name
		self.arguments=arguments
		self.fields = List::new()
		self.packed = packed
		self.proj=p
	return self

	function(GType self, GenericArgs params) GType:apply -> OType does
		cstr mangled_name = self.name+".G_"

		int i=0
		while i<params:len() do
			mangled_name+="A"+params:get_idx(i).name+"Z"
			if i!=params:len()-1 do
				mangled_name+="."
			done
			i+=1
		done

		if self.proj.types:contains(mangled_name) do
			return self.proj:get_type(mangled_name)
		done
		
		StructOType new_t = StructOType::new(mangled_name)|StructOType
		new_t.packed=self.packed
		self.proj:add_Type(new_t|OType)

		i=0
		while i<self.fields.len do
			TypedVar orig_var = self.fields:get_TypedVar(i)
			OType resolved_var = orig_var.type_
			if resolved_var.variety==SYMTYPE do
				resolved_var=params:get_name(resolved_var.name)
			done
			resolved_var=resolved_var:resolve(params)
			new_t:add_field(TypedVar::new(orig_var.name, resolved_var))
			i+=1
		done
	return new_t|OType

	function(GType self) GType:print -> void does
		printf("GType: %s ", self.name)
		if self.packed do
			printf("packed ")
		done
		printf("\n")
		int i=0
		while i<self.fields.len do
			printf(" -field: %s:", self.fields:get_TypedVar(i).name)
			self.fields:get_TypedVar(i).type_:print()
			i+=1
		done
		i=0
		while i<self.arguments:len() do
			printf(" -arg: %s: ", self.arguments:get_name_for_idx(i))
			if self.arguments:get_idx(i)|ptr!=null do
				self.arguments:get_idx(i):print()
			else do
				printf(" [no default]\n")
			done
			i+=1
		done
	return
endtype

type PType is packed
	int variety
	cstr name
	Project proj
	GType generic
	GenericArgs arguments #(map of generic name -> OType OR null if using default)

	function(GType generic, GenericArgs arguments) PType::new -> OType does
		PType self = malloc(@sizeof(PType)@)|PType
		self.generic=generic
		self.arguments=arguments
		self.variety=PTYPE
		self.name="[Generic Of: "+generic.name+": "
		int i=0
		while i<arguments:len() do
			self.name+=arguments:get_idx(i).name
			if i!=arguments:len()-1 do
				self.name+=", "
			done
			i+=1
		done
		self.name+="]"
	return self|OType

	function(PType self, GenericArgs params) PType:resolve -> OType does
		int i=0
		GenericArgs inst_args = GenericArgs::copy(self.arguments)
		while i<self.arguments:len() do
			if self.arguments:get_idx(i).variety==SYMTYPE do
				self.arguments:set(self.arguments:get_name_for_idx(i), params:get_name(self.arguments:get_name_for_idx(i)))
			done
			i+=1
		done
	return self.generic:apply(self.arguments)

	function(PType self) PType:print -> void does
		printf("PType %s\n", self.name)
		int i=0
		while i<self.arguments:len() do
			printf("\t-param: %s: ", self.arguments:get_name_for_idx(i))
			self.arguments:get_idx(i):print()
			i+=1
		done
	return
endtype

type SymType is packed
	int variety
	cstr name
	Project proj

	function(cstr name) SymType::new -> OType does
		SymType self = malloc(@sizeof(SymType)@)|SymType
		self.variety=SYMTYPE
		self.name=name
	return self|OType

	function(SymType self) SymType:print -> void does
		printf("[SymType %s]\n", self.name)
	return
endtype

type GMethod is
	Project proj
	cstr name
	List args #list of TypedVars
	OType return_value
	GenericArgs generic_args
	FunctionDecl ast

	function(Project proj, GenericName name, List args_nodes, NameExpr return_value, FunctionDecl ast) GMethod::new -> GMethod does
		GMethod new = malloc(@sizeof(GMethod)@)|GMethod
		new.proj=proj
		new.name=name.base_name
		new.generic_args=GenericArgs::new()

		int i=0
		while i<name.args.len do
			new.generic_args:add_null(name.args:get(i)|NameExpr.name)
			i+=1
		done

		new.return_value=generic::resolve_symdecl(proj, return_value, new.generic_args)

		new.args=List::new()
		i=0
		while i<args_nodes.len do
			new.args:append_TypedVar(TypedVar::new(args_nodes:get(i)|DeclExpr.d_name,\
			 generic::resolve_symdecl(proj, args_nodes:get(i)|DeclExpr.d_type, new.generic_args)))
			i+=1
		done

		new.ast=ast
	return new

	function(GMethod self) GMethod:print -> void does
		printf("GMethod `%s` -> ", self.name)
		self.return_value:print()
		int i=0
		while i<self.args.len do
			TypedVar t = self.args:get_TypedVar(i)
			printf(" - arg `%s` : ", t.name)
			t.type_:print()
			i+=1
		done

		i=0
		while i<self.generic_args:len() do
			printf(" - param `%s`\n", self.generic_args:get_name_for_idx(i))
			i+=1
		done
	return

	function(GMethod self, GenericArgs args) GMethod:resolve -> Method does
		shoc::bail_out(":resolve")
	return null|Method
endtype

function(Project proj) generic::implement_generics -> void does
	# printf("Implementing Generics... %i Methods...\n", proj.methods:num_keys())
	int i=0

	while i<proj.methods:num_keys() do
		generic::implement_method(proj, proj.methods:get_by_num(i)|Method)
		i+=1
	done
return

function(Project proj, Method meth) generic::implement_method -> void does
	# printf("Generifying Method: %s\n", meth.name)
	int i=0
	while i<meth.locals:num_keys() do
		OType l_type = meth.locals:get_by_num(i)|OType
		meth.locals:set(meth.locals:get_key_by_num(i), l_type:resolve(GenericArgs::new())|ptr)
		i+=1
	done
return

function(FileNode n, TransformerPass p) implement_generics::visit_file -> FileNode does
	generic::implement_generics(p.proj)
return n

function() implement_generics::init -> TransformerPass does
return TransformerPass::new("implement_generics"):no_auto_visit()\
       :add_specialization("FileNode", implement_generics::visit_file|NodeTransformer)

function(CallExpr n, TransformerPass p) list_generics::visit_call -> CallExpr does
	if n.meth:is_a("GenericName") do
		GenericName gn = n.meth|GenericName
		GenericArgs g_args = GenericArgs::copy(p.proj.generic_methods:get(gn.base_name)|GMethod.generic_args)
		int i=0
		while i<gn.args.len do
			# g_args:set_idx(i, null|OType)
			g_args:set(g_args:get_name_for_idx(i), p.proj:resolve_TypeName(gn.args:get(i)|NameExpr))
			i+=1
		done
		n.meth=NameExpr::create_direct(\
			p.proj.generic_methods:get(gn.base_name)|GMethod:resolve(g_args).name, n.meth|GenericName.anchor)|Node
	done
return n

function() list_generics::init -> TransformerPass does
return TransformerPass::new("list_generics")\
       :add_specialization("CallExpr", list_generics::visit_call|NodeTransformer)

function(Project proj, NameExpr typename, GenericArgs g_args) generic::resolve_symdecl -> OType does
	if typename.type_==NameExpr_t do
		if proj.types:contains(typename.name) do
			return proj:get_type(typename.name)
		elif g_args:contains(typename.name) do
			return SymType::new(typename.name)
		else do
			shoc::bail_out("Can't resolve name: "+typename.name)
		done
	elif typename.type_==GenericName_t do
		GenericName gn = typename|GenericName
		GType g_type = proj.generic_types:get(gn.base_name)|GType
		GenericArgs args = GenericArgs::copy(g_type.arguments)
		int i = 0
		while i<gn.args.len do
			args:set(args:get_name_for_idx(i), generic::resolve_symdecl(proj, gn.args:get_Node(i)|NameExpr, g_args))
			i+=1
		done
		return PType::new(g_type, args)|OType
	done
	typename|Node:print_root()
	shoc::bail_out("Can't resolve name (how did we get here)")
return null|OType