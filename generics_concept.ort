
type MapNode is generic over {Key, Value}
	MapNode{Key, Value} next
	Key key
	Value value

	function(Key key, Value value) MapNode::new{Key, Value} -> MapNode{Key, Value} does
		?n = mem::alloc{MapNode{Key, Value}}()
		n.key=key
		n.value=value
	return n
endtype

type Map is generic over {Key, Value}
	List{MapNode{Key, Value}} _list

	function() Map::new{Key, Value} -> Map{Key, Value} does
		?n = mem::alloc{Map{Key, Value}}()
		n._list=List::new{MapNode{Key, Value}}()
	return n

	function(Map{Key, Value} self, Key key, Value value) Map:set -> void does
		if self:contains(key) do
			self._get_node(key).value=value
		else do
			self._list:append(MapNode::new{Key, Value}(key, value))
		done
	return
endtype

Idea: for generic functions like MapNode::new{Key, Value}(key, value), maybe infer type-args Key and Value from types of args of that generic type



Idea: ? prefix for non-typed names to make them dynamic decls, so 
?mapping = Map::new{str,str}()
turns into
Map{str, str} mapping = Map::new{str, str}()
since Map::new{str, str} returns Map{str, str}